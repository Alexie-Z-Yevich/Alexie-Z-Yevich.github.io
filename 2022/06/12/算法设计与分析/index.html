<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>算法设计与分析 | New Try &amp;&amp; New Life</title><meta name="author" content="Alexie-Z-Yevich"><meta name="copyright" content="Alexie-Z-Yevich"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前置知识vectorC++ STL中的verctor好比是C语言中的数组，但是vector又具有数组没有的一些高级功能。与数组相比，vector就是一个可以不用再初始化就必须制定大小的边长数组。 算法中常见的vector L(n, 0)表示生成一个L包含n个重复的元素，每个元素值为0。  setset就是集合，STL的set用二叉树实现，集合中的每个元素只出现一次(参照数学中集合的互斥性)，并且是">
<meta property="og:type" content="article">
<meta property="og:title" content="算法设计与分析">
<meta property="og:url" content="https://www.fenrisx.icu/2022/06/12/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="New Try &amp;&amp; New Life">
<meta property="og:description" content="前置知识vectorC++ STL中的verctor好比是C语言中的数组，但是vector又具有数组没有的一些高级功能。与数组相比，vector就是一个可以不用再初始化就必须制定大小的边长数组。 算法中常见的vector L(n, 0)表示生成一个L包含n个重复的元素，每个元素值为0。  setset就是集合，STL的set用二叉树实现，集合中的每个元素只出现一次(参照数学中集合的互斥性)，并且是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.fenrisx.icu/images/head.jpg">
<meta property="article:published_time" content="2022-06-12T12:37:30.000Z">
<meta property="article:modified_time" content="2023-03-30T13:26:52.831Z">
<meta property="article:author" content="Alexie-Z-Yevich">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.fenrisx.icu/images/head.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.fenrisx.icu/2022/06/12/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Alexie-Z-Yevich","link":"链接: ","source":"来源: New Try && New Life","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法设计与分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-30 21:26:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">50</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/attacks/"><i class="fa-fw fas fa-images"></i><span> 哒咩</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="New Try &amp;&amp; New Life"><span class="site-name">New Try &amp;&amp; New Life</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/attacks/"><i class="fa-fw fas fa-images"></i><span> 哒咩</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法设计与分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-12T12:37:30.000Z" title="发表于 2022-06-12 20:37:30">2022-06-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-30T13:26:52.831Z" title="更新于 2023-03-30 21:26:52">2023-03-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/">我的大学</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E5%AD%A6%E6%9C%9F/">大二下学期</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法设计与分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h6 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h6><p>C++ STL中的verctor好比是C语言中的数组，但是vector又具有数组没有的一些高级功能。与数组相比，vector就是一个可以不用再初始化就必须制定大小的边长数组。</p>
<p>算法中常见的vector<int> L(n, 0)表示生成一个L包含n个重复的元素，每个元素值为0。</int></p>
<p><img src="/2022/06/12/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/vector%E8%AF%B4%E6%98%8E.png" alt="vector说明"></p>
<h6 id="set"><a href="#set" class="headerlink" title="set"></a>set</h6><p>set就是集合，STL的set用二叉树实现，集合中的每个元素只出现一次(参照数学中集合的互斥性)，并且是排好序的(默认按键值升序排列)</p>
<p>访问元素的时间复杂度是O(log2n) 。</p>
<h6 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h6><p>queue是一种容器转换器模板，调用#include&lt; queue&gt;即可使用队列类。在算法中通常是作为FIFO队列使用。</p>
<p>常见形式：queue&lt;Type, Container&gt; (&lt;数据类型，容器类型&gt;）</p>
<h6 id="functional"><a href="#functional" class="headerlink" title="functional"></a>functional</h6><p>类模板std::function是通用多态函数封装器。 std::function的实例能存储、复制及调用任何可调用函数、 lambda表达式、 bind表达式或其他函数对象，还有指向成员函数指针和指向数据成员指针。</p>
<p>简单来说就是在函数中实现内嵌函数，但是内嵌函数同样适用于递归，且可以获得外层函数的参数。</p>
<h6 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BtNode</span></span><br><span class="line">&#123; </span><br><span class="line">    T data;</span><br><span class="line"> 	<span class="type">int</span> depth = <span class="number">1</span>;</span><br><span class="line"> 	BtNode *left = <span class="number">0</span>, *right = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构体属于用户自定义的数据类型，允许用户存储不同的数据类型。写法如上述。</p>
<h6 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h6><p>矩阵运算库，在算法中以老师给的Matrix.hpp为准，建议浏览一下内容，知道诸如.row()函数、G(x,y)等运算都来源于自建库，附上我使用版本的Matrix.hpp：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Matrix.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span></span><br><span class="line">&#123;  </span><br><span class="line">   vector&lt;T&gt; buf; <span class="comment">// 用一维数组保存矩阵元素</span></span><br><span class="line">   <span class="type">size_t</span> r = <span class="number">0</span>, c = <span class="number">0</span>; <span class="comment">// 行数和列数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Matrix</span>() = <span class="keyword">default</span>; <span class="comment">// 默认初始化</span></span><br><span class="line">   <span class="built_in">Matrix</span>(<span class="type">const</span> Matrix &amp;m) = <span class="keyword">default</span>; <span class="comment">// 使用另一矩阵初始化</span></span><br><span class="line">   ~<span class="built_in">Matrix</span>() = <span class="keyword">default</span>; <span class="comment">// 析构</span></span><br><span class="line">   Matrix &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Matrix &amp;) = <span class="keyword">default</span>; <span class="comment">// 赋值</span></span><br><span class="line">   <span class="built_in">Matrix</span>(<span class="type">size_t</span> row, <span class="type">size_t</span> col): <span class="comment">// 根据行数和列数初始化</span></span><br><span class="line">      <span class="built_in">buf</span>(<span class="built_in">vector</span>&lt;T&gt;(row * col)), <span class="built_in">r</span>(row), <span class="built_in">c</span>(col) &#123;&#125;</span><br><span class="line">   <span class="built_in">Matrix</span>(<span class="type">size_t</span> row, <span class="type">size_t</span> col, <span class="type">const</span> T &amp;v): <span class="comment">// 用行数和列数及指定值初始化</span></span><br><span class="line">      <span class="built_in">buf</span>(<span class="built_in">vector</span>&lt;T&gt;(row * col, v)), <span class="built_in">r</span>(row), <span class="built_in">c</span>(col) &#123;&#125;</span><br><span class="line">   <span class="comment">// 使用初始值列表初始化, 即使用&#123;&#125;初始化</span></span><br><span class="line">   <span class="built_in">Matrix</span>(<span class="type">const</span> initializer_list&lt;initializer_list&lt;T&gt;&gt; &amp;m):</span><br><span class="line">      <span class="built_in">buf</span>(<span class="built_in">begin</span>(m)-&gt;<span class="built_in">begin</span>(), <span class="built_in">rbegin</span>(m)-&gt;<span class="built_in">end</span>()), <span class="comment">// 指定元素</span></span><br><span class="line">      <span class="built_in">r</span>(m.<span class="built_in">size</span>()), <span class="built_in">c</span>(<span class="built_in">begin</span>(m)-&gt;<span class="built_in">size</span>()) <span class="comment">// 指定行数和列数</span></span><br><span class="line">   &#123;&#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">const</span> T &amp;v)</span> <span class="comment">// 每个元素都是v</span></span></span><br><span class="line"><span class="function">   </span>&#123;  </span><br><span class="line">      buf.<span class="built_in">assign</span>(r * c, v);</span><br><span class="line">   &#125; <span class="comment">// 耗时O(size)</span></span><br><span class="line">   <span class="comment">// 元素类型简写</span></span><br><span class="line">   <span class="keyword">using</span> reference = <span class="keyword">typename</span> vector&lt;T&gt;::reference; <span class="comment">// 元素引用</span></span><br><span class="line">   <span class="keyword">using</span> const_reference = <span class="keyword">typename</span> vector&lt;T&gt;::const_reference; <span class="comment">// const引用</span></span><br><span class="line">   <span class="function">reference <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">size_t</span> i, <span class="type">size_t</span> j)</span> <span class="comment">// 使用M(i, j)的形式访问矩阵元素</span></span></span><br><span class="line"><span class="function">   </span>&#123;  </span><br><span class="line">      <span class="keyword">return</span> buf[i * c + j];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">const_reference <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">size_t</span> i, <span class="type">size_t</span> j)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">   </span>&#123;  </span><br><span class="line">      <span class="keyword">return</span> buf[i * c + j];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">rows</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> r; &#125; <span class="comment">// 行数</span></span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">cols</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c; &#125; <span class="comment">// 列数</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// extend</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="built_in">Matrix</span>(Matrix &amp;&amp;m): <span class="built_in">buf</span>(<span class="built_in">move</span>(m.buf)), <span class="built_in">r</span>(m.r), <span class="built_in">c</span>(m.c) &#123;&#125;</span><br><span class="line">   Matrix &amp;<span class="keyword">operator</span>=(Matrix &amp;&amp;m)</span><br><span class="line">   &#123;  </span><br><span class="line">      buf = <span class="built_in">move</span>(m.buf), r = m.r, c = m.c;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Matrix &amp;<span class="keyword">operator</span>=(<span class="type">const</span> initializer_list&lt;T&gt; &amp;m)</span><br><span class="line">   &#123;  </span><br><span class="line">      buf.<span class="built_in">assign</span>(m);</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125; <span class="comment">// 使用列表赋值，即将&#123;&#125;中的元素复制到*this</span></span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> r * c; &#125; <span class="comment">// 元素数</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// end extend</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// 输出矩阵的所有元素</span></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> Matrix&lt;T&gt; &amp;m)</span><br><span class="line">&#123;  </span><br><span class="line">   <span class="type">size_t</span> r = m.<span class="built_in">rows</span>(), c = m.<span class="built_in">cols</span>();</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; r; ++i)</span><br><span class="line">   &#123;  </span><br><span class="line">       <span class="keyword">for</span>(<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; c; ++j)</span><br><span class="line">         out &lt;&lt; <span class="built_in">m</span>(i, j) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      out &lt;&lt; endl; <span class="comment">// 输出一行元素后换行</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> out;</span><br><span class="line">&#125; <span class="comment">// 耗时O(size)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// extend</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// 两个矩阵相加</span></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">operator</span>+(<span class="type">const</span> Matrix&lt;T&gt; &amp;X, <span class="type">const</span> Matrix&lt;T&gt; &amp;Y)</span><br><span class="line">&#123;  </span><br><span class="line">   <span class="type">size_t</span> r = <span class="built_in">min</span>(X.<span class="built_in">rows</span>(), Y.<span class="built_in">rows</span>()), c = <span class="built_in">min</span>(X.<span class="built_in">cols</span>(), Y.<span class="built_in">cols</span>());</span><br><span class="line">   <span class="function">Matrix&lt;T&gt; <span class="title">Z</span><span class="params">(r, c)</span></span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; r; ++i)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; c; ++j)</span><br><span class="line">         <span class="built_in">Z</span>(i, j) = <span class="built_in">X</span>(i, j) + <span class="built_in">Y</span>(i, j);</span><br><span class="line">   <span class="keyword">return</span> Z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// 两个矩阵相减</span></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">operator</span>-(<span class="type">const</span> Matrix&lt;T&gt; &amp;X, <span class="type">const</span> Matrix&lt;T&gt; &amp;Y)</span><br><span class="line">&#123;  </span><br><span class="line">   <span class="type">size_t</span> r = <span class="built_in">min</span>(X.<span class="built_in">rows</span>(), Y.<span class="built_in">rows</span>()), c = <span class="built_in">min</span>(X.<span class="built_in">cols</span>(), Y.<span class="built_in">cols</span>());</span><br><span class="line">   <span class="function">Matrix&lt;T&gt; <span class="title">Z</span><span class="params">(r, c)</span></span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; r; ++i)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; c; ++j)</span><br><span class="line">         <span class="built_in">Z</span>(i, j) = <span class="built_in">X</span>(i, j) - <span class="built_in">Y</span>(i, j);</span><br><span class="line">   <span class="keyword">return</span> Z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// 两个矩阵相乘</span></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">operator</span>*(<span class="type">const</span> Matrix&lt;T&gt; &amp;X, <span class="type">const</span> Matrix&lt;T&gt; &amp;Y)</span><br><span class="line">&#123;  </span><br><span class="line">   <span class="type">size_t</span> r = X.<span class="built_in">rows</span>(), c = Y.<span class="built_in">cols</span>(), m = <span class="built_in">min</span>(X.<span class="built_in">cols</span>(), Y.<span class="built_in">rows</span>());</span><br><span class="line">   <span class="function">Matrix&lt;T&gt; <span class="title">Z</span><span class="params">(r, c)</span></span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; r; ++i)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; c; ++j)</span><br><span class="line">      &#123;  </span><br><span class="line">         <span class="built_in">Z</span>(i, j) = <span class="built_in">X</span>(i, <span class="number">0</span>) * <span class="built_in">Y</span>(<span class="number">0</span>, j);</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">size_t</span> k = <span class="number">1</span>; k &lt; m; ++k)</span><br><span class="line">            <span class="built_in">Z</span>(i, j) = <span class="built_in">Z</span>(i, j) + <span class="built_in">X</span>(i, k) * <span class="built_in">Y</span>(k, j);</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">return</span> Z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="comment">// 加上一个值</span></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">operator</span>+(<span class="type">const</span> Matrix&lt;T&gt; &amp;X, <span class="type">const</span> T2 &amp;v)</span><br><span class="line">&#123;  </span><br><span class="line">   <span class="type">size_t</span> r = X.<span class="built_in">rows</span>(), c = X.<span class="built_in">cols</span>();</span><br><span class="line">   <span class="function">Matrix&lt;T&gt; <span class="title">Z</span><span class="params">(r, c)</span></span>; <span class="comment">// 结果矩阵</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; r; ++i)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; c; ++j)</span><br><span class="line">         <span class="built_in">Z</span>(i, j) = <span class="built_in">X</span>(i, j) + v;</span><br><span class="line">   <span class="keyword">return</span> Z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="comment">// 减去一个值</span></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">operator</span>-(<span class="type">const</span> Matrix&lt;T&gt; &amp;X, <span class="type">const</span> T2 &amp;v)</span><br><span class="line">&#123;  </span><br><span class="line">   <span class="type">size_t</span> r = X.<span class="built_in">rows</span>(), c = X.<span class="built_in">cols</span>();</span><br><span class="line">   <span class="function">Matrix&lt;T&gt; <span class="title">Z</span><span class="params">(r, c)</span></span>; <span class="comment">// 结果矩阵</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; r; ++i)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; c; ++j)</span><br><span class="line">         <span class="built_in">Z</span>(i, j) = <span class="built_in">X</span>(i, j) - v;</span><br><span class="line">   <span class="keyword">return</span> Z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="comment">// 乘以一个值</span></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">operator</span>*(<span class="type">const</span> Matrix&lt;T&gt; &amp;X, <span class="type">const</span> T2 &amp;v)</span><br><span class="line">&#123;  </span><br><span class="line">   <span class="type">size_t</span> r = X.<span class="built_in">rows</span>(), c = X.<span class="built_in">cols</span>();</span><br><span class="line">   <span class="function">Matrix&lt;T&gt; <span class="title">Z</span><span class="params">(r, c)</span></span>; <span class="comment">// 结果矩阵</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; r; ++i)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; c; ++j)</span><br><span class="line">         <span class="built_in">Z</span>(i, j) = <span class="built_in">X</span>(i, j) * v;</span><br><span class="line">   <span class="keyword">return</span> Z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="comment">// 除以一个值</span></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">operator</span>/(<span class="type">const</span> Matrix&lt;T&gt; &amp;X, <span class="type">const</span> T2 &amp;v)</span><br><span class="line">&#123;  </span><br><span class="line">   <span class="type">size_t</span> r = X.<span class="built_in">rows</span>(), c = X.<span class="built_in">cols</span>();</span><br><span class="line">   <span class="function">Matrix&lt;T&gt; <span class="title">Z</span><span class="params">(r, c)</span></span>; <span class="comment">// 结果矩阵</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; r; ++i)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; c; ++j)</span><br><span class="line">         <span class="built_in">Z</span>(i, j) = <span class="built_in">X</span>(i, j) / v;</span><br><span class="line">   <span class="keyword">return</span> Z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// 负</span></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">operator</span>-(<span class="type">const</span> Matrix&lt;T&gt; &amp;X)</span><br><span class="line">&#123;  </span><br><span class="line">   <span class="keyword">return</span> X * (<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// 转置</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">transpose</span><span class="params">(<span class="type">const</span> Matrix&lt;T&gt; &amp;X)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="type">size_t</span> r = X.<span class="built_in">cols</span>(), c = X.<span class="built_in">rows</span>();</span><br><span class="line">   <span class="function">Matrix&lt;T&gt; <span class="title">Z</span><span class="params">(r, c)</span></span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; r; ++i)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; c; ++j)</span><br><span class="line">         <span class="built_in">Z</span>(i, j) = <span class="built_in">X</span>(j, i);</span><br><span class="line">   <span class="keyword">return</span> Z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// end extend</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>





<h2 id="渐进符号"><a href="#渐进符号" class="headerlink" title="渐进符号"></a>渐进符号</h2><h4 id="渐进符号O（上界）【考点】"><a href="#渐进符号O（上界）【考点】" class="headerlink" title="渐进符号O（上界）【考点】"></a>渐进符号O（上界）【考点】</h4><h6 id="1、符号O的定义"><a href="#1、符号O的定义" class="headerlink" title="1、符号O的定义"></a>1、符号O的定义</h6><p>f(n) &#x3D; O(g(n))当且仅当存在正整数c和n0，使得n &gt;&#x3D; n0时，有f(n) &lt;&#x3D; c * g(n)。此时，称g(n)是f(n)的一个上界。</p>
<table>
<thead>
<tr>
<th align="center"><strong>常数函数</strong></th>
<th align="center">f(n) &#x3D; C0 &#x3D; O(1)</th>
<th align="center">c &#x3D; C0, n0 &#x3D; 0</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>线性函数</strong></td>
<td align="center"><strong>3n + 2 &#x3D; O(n)</strong></td>
<td align="center"><strong>c &#x3D; 4, n0 &#x3D; 2</strong></td>
</tr>
<tr>
<td align="center"><strong>线性函数</strong></td>
<td align="center"><strong>100n + 6lnn &#x3D; O(n)</strong></td>
<td align="center"><strong>c &#x3D; 102, n0 &#x3D; 6</strong></td>
</tr>
<tr>
<td align="center"><strong>平方函数</strong></td>
<td align="center"><strong>10n ^ 2 + 4n + 3 &#x3D; O(n ^ 2)</strong></td>
<td align="center"><strong>c &#x3D; 11, n0 &#x3D; 5</strong></td>
</tr>
<tr>
<td align="center"><strong>平方函数</strong></td>
<td align="center"><strong>nlogn + n ^ 2 &#x3D; O(n ^ 2)</strong></td>
<td align="center"><strong>c &#x3D; 2, n0 &#x3D; 3</strong></td>
</tr>
<tr>
<td align="center"><strong>指数函数</strong></td>
<td align="center"><strong>6 x 2 ^ n + n ^ 2 &#x3D; O(2 ^ n)</strong></td>
<td align="center"><strong>c &#x3D; 7, n0 &#x3D; 4</strong></td>
</tr>
<tr>
<td align="center"><strong>松散界限</strong></td>
<td align="center"><strong>3n + 2 &#x3D; O(n ^ 2)</strong></td>
<td align="center"><strong>c &#x3D; 3, n0 &#x3D; 2</strong></td>
</tr>
<tr>
<td align="center"><strong>错误界限</strong></td>
<td align="center"><strong>3n + 2 ≠ O(1)</strong></td>
<td align="center"></td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<p>（1）不要产生松散界限；（2）不要产生错误界限；（3）f(n)与g(n)顺序不能调转。</p>
<h6 id="2、【大O比率定理】"><a href="#2、【大O比率定理】" class="headerlink" title="2、【大O比率定理】"></a>2、【大O比率定理】</h6><p>$$<br>对于函数f(n)和g(n)，如果\lim_{n\rightarrow + \infty}\frac{f(n)}{g(n)}存在，则f(n) &#x3D; O(g(n))当且仅当c &gt; 0,使得\lim_{n\rightarrow + \infty}\frac{f(n)}{g(n)} ≤ c。<br>$$</p>
<h6 id="3、【常用上界关系定理】-由大O比率定理证明"><a href="#3、【常用上界关系定理】-由大O比率定理证明" class="headerlink" title="3、【常用上界关系定理】 (由大O比率定理证明)"></a>3、【常用上界关系定理】 (由大O比率定理证明)</h6><p>$$<br>对于任何正数x和ε，<br>\log^{-x}n &#x3D; O(1),<br>x &#x3D; O(\log^{ε}n),<br>\log^{x}n &#x3D; O(\log^{x + ε}n),<br>\log^{x}n &#x3D; O(n^{ε}),\<br>n^x &#x3D; O(n^{x + ε}),<br>n^x &#x3D; O(2^n)和2^n &#x3D; O(2!)<br>等上界关系都成立。<br>$$</p>
<p><strong>总结：</strong>常用上界关系就是通常所说的向上约分，需要注意的是常用上界关系定理中的转换公式，理解与学会转换诸如：<br>$$<br>\log^{20}n &#x3D; O(n^{1.5})<br>$$</p>
<h4 id="渐进符号Ω（下界）"><a href="#渐进符号Ω（下界）" class="headerlink" title="渐进符号Ω（下界）"></a>渐进符号Ω（下界）</h4><h6 id="1、符号Ω的定义"><a href="#1、符号Ω的定义" class="headerlink" title="1、符号Ω的定义"></a>1、符号Ω的定义</h6><p>f(n) &#x3D; Ω(g(n))当且仅当存在正常数c和n0，使得当n ≥ n0时，有f(n) &gt;&#x3D; c * g(n)。</p>
<h6 id="2、【大Ω比率定理】"><a href="#2、【大Ω比率定理】" class="headerlink" title="2、【大Ω比率定理】"></a>2、【大Ω比率定理】</h6><p>$$<br>对于f(n)和g(n)，如果\lim_{n\rightarrow + \infty}\frac{g(n)}{f(n)}存在，则f(n) &#x3D; Ω(g(n))当且仅当存在c &gt; 0，使得\lim_{n\rightarrow + \infty}\frac{g(n)}{f(n)} &lt;&#x3D; c。<br>$$</p>
<h4 id="渐进符号Θ（双界）"><a href="#渐进符号Θ（双界）" class="headerlink" title="渐进符号Θ（双界）"></a>渐进符号Θ（双界）</h4><h6 id="1、符号Θ的定义"><a href="#1、符号Θ的定义" class="headerlink" title="1、符号Θ的定义"></a>1、符号Θ的定义</h6><p>f(n) &#x3D; Θ(g(n))当且仅当存在正常数c1，c2和n0，使得当n &gt;&#x3D; n0时，有c1 * g(n) &lt;&#x3D; f(n) &lt;&#x3D; c2 * g(n)。</p>
<h6 id="2、【大Θ比率定理】"><a href="#2、【大Θ比率定理】" class="headerlink" title="2、【大Θ比率定理】"></a>2、【大Θ比率定理】</h6><p>$$<br>对于函数f(n)和g(n)，如果\lim_{n\rightarrow + \infty}\frac{f(n)}{g(n)}与\lim_{n\rightarrow + \infty}\frac{g(n)}{f(n)}都存在，则f(n) &#x3D; Θ(g(n))当且仅当存在正常数c1，c2，\<br>使得\lim_{n\rightarrow + \infty}\frac{g(n)}{f(n)} &lt;&#x3D; c1, \lim_{n\rightarrow + \infty}\frac{f(n)}{g(n)} &lt;&#x3D; c2。<br>$$</p>
<ul>
<li>大Θ比率定理是大O比率定理与大Ω比率定理的结合。</li>
</ul>
<h4 id="简化Master定理【考点】"><a href="#简化Master定理【考点】" class="headerlink" title="简化Master定理【考点】"></a>简化Master定理【考点】</h4><h6 id="1、定理适用范围"><a href="#1、定理适用范围" class="headerlink" title="1、定理适用范围"></a>1、定理适用范围</h6><p>当a &gt; 0, b &gt; 1, α &gt;&#x3D; 0时，对于形如T(n) &#x3D; aT(n &#x2F; b) + X(n ^ α)（其中，X代表O、Ω、Θ之一，n &#x2F; b可以理解为[n &#x2F; b]【这里无法描述】）的递归函数，可以使用简化Master定理找到他们的渐进函数。</p>
<h6 id="2、简化Master定理"><a href="#2、简化Master定理" class="headerlink" title="2、简化Master定理"></a>2、简化Master定理</h6><p>$$<br>当a &gt; 0, b &gt; 1, α &gt;&#x3D; 0时，递归函数T(n) &#x3D; aT(n &#x2F; b) + X(n ^ α)(X代表O、Ω、Θ之一)的渐进函数为 \<br>T(n) &#x3D;<br>\begin{cases}<br>X(n^{\log_ba}), α &lt; \log_ba \<br>X(n^αlogn), α &#x3D; \log_ba \<br>X(n^α), α &gt; \log_ba<br>\end{cases}<br>$$</p>
<ul>
<li>通过简化Master定理我们求的是<strong>Θ的渐进函数</strong>。</li>
</ul>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h6 id="选择排序（升序排列）"><a href="#选择排序（升序排列）" class="headerlink" title="选择排序（升序排列）"></a>选择排序（升序排列）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(T X[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line"> 		<span class="keyword">if</span>(X[pos] &lt; X[i]) pos = i;</span><br><span class="line"> 	<span class="keyword">return</span> pos;  <span class="comment">// 返回数组最大值的下标</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectionSort</span><span class="params">(T X[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> m = n; m &gt; <span class="number">1</span>; --m)&#123; </span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">Max</span>(X, m);  <span class="comment">// 找到当前数组的最大值</span></span><br><span class="line"> 		<span class="built_in">swap</span>(X[i], X[m - <span class="number">1</span>]);  <span class="comment">// 将最大值与数组未遍历末位交换</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 时间复杂度为O(n ^ 2)</span></span><br></pre></td></tr></table></figure>

<h6 id="插入排序（升序排列且不含重复元素）"><a href="#插入排序（升序排列且不含重复元素）" class="headerlink" title="插入排序（升序排列且不含重复元素）"></a>插入排序（升序排列且不含重复元素）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将元素插入到有序数组中</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Insert</span><span class="params">(T X[], <span class="type">int</span> m, <span class="type">const</span> T2 &amp;v)</span>  <span class="comment">// v为要插入的元素</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> p;</span><br><span class="line"> 	<span class="keyword">for</span>(p = m - <span class="number">1</span>; p &gt;= <span class="number">0</span> <span class="keyword">and</span> X[p] &gt; v; --p) &#123;&#125;  <span class="comment">// 用p记录第一个比v小的数组下标</span></span><br><span class="line"> 	<span class="keyword">if</span>(X[p] == v) <span class="keyword">return</span> m;  <span class="comment">// 如果两数据相等，不执行插入操作</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = m - <span class="number">1</span>; i &gt; p; --i)</span><br><span class="line"> 		X[i + <span class="number">1</span>] = X[i];  <span class="comment">// 所有数据向后移一位</span></span><br><span class="line"> 	X[p + <span class="number">1</span>] = v;</span><br><span class="line"> 	<span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 时间复杂度为O(m)</span></span><br></pre></td></tr></table></figure>

<h6 id="插入排序（升序排列）"><a href="#插入排序（升序排列）" class="headerlink" title="插入排序（升序排列）"></a>插入排序（升序排列）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将无序数组进行插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(T X[], <span class="type">int</span> m, <span class="type">const</span> T &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"> 	<span class="keyword">for</span>(i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span> <span class="keyword">and</span> X[i] &gt; v; --i)  <span class="comment">// 找到第一个比传入元素小的下标，将其他元素向后移动</span></span><br><span class="line"> 		X[i + <span class="number">1</span>] = X[i];</span><br><span class="line"> 	X[i + <span class="number">1</span>] = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertionSort</span><span class="params">(T X[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> m = <span class="number">1</span>; m &lt; n; ++m)&#123; </span><br><span class="line">		<span class="keyword">auto</span> v = X[m];</span><br><span class="line"> 		<span class="built_in">Insert</span>(X, m, v);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 时间复杂度为O(n ^ 2)</span></span><br></pre></td></tr></table></figure>



<h2 id="图遍历方法"><a href="#图遍历方法" class="headerlink" title="图遍历方法"></a>图遍历方法</h2><h6 id="一般树的先序遍历"><a href="#一般树的先序遍历" class="headerlink" title="一般树的先序遍历"></a>一般树的先序遍历</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BtNode</span></span><br><span class="line">&#123; </span><br><span class="line">    T data;</span><br><span class="line"> 	BtNode *left = <span class="number">0</span>, *right = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Func&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BtNode&lt;T&gt; *x, Func Visit)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"> 	<span class="built_in">Visit</span>(x);</span><br><span class="line"> 	<span class="built_in">PreOrder</span>(x-&gt;left, Visit);</span><br><span class="line"> 	<span class="built_in">PreOrder</span>(x-&gt;right, Visit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BtNode</span></span><br><span class="line">&#123; </span><br><span class="line">    T data;</span><br><span class="line"> 	BtNode *left = <span class="number">0</span>, *right = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Func&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BtNode&lt;T&gt; *x, Func Visit)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	queue&lt;BtNode&lt;T&gt; *&gt; Q;  <span class="comment">// 创建队列（先入先出）</span></span><br><span class="line"> 	<span class="built_in">Visit</span>(x), Q.<span class="built_in">push</span>(x);</span><br><span class="line"> 	<span class="keyword">while</span>(<span class="keyword">not</span> Q.<span class="built_in">empty</span>())&#123; </span><br><span class="line">        x = Q.<span class="built_in">front</span>(), Q.<span class="built_in">pop</span>();  <span class="comment">// 取Q队列的第一个元素出队。</span></span><br><span class="line"> 		<span class="keyword">auto</span> left = x-&gt;left, right = x-&gt;right;</span><br><span class="line"> 		<span class="keyword">if</span>(left != <span class="number">0</span>)</span><br><span class="line"> 			<span class="built_in">Visit</span>(left), Q.<span class="built_in">push</span>(left);  <span class="comment">// 将x左子树元素入队</span></span><br><span class="line"> 		<span class="keyword">if</span>(right != <span class="number">0</span>)</span><br><span class="line"> 			<span class="built_in">Visit</span>(right), Q.<span class="built_in">push</span>(right);  <span class="comment">// 将x右子树元素入队</span></span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其实类似先序遍历，都是先执行Visit操作后再进行左右子树判断；</span></span><br><span class="line"><span class="comment">// 主要区别在于层次遍历是一个入队出队操作，先判断队列中是否有元素，再去将元素的左右子树依次入队。</span></span><br></pre></td></tr></table></figure>

<h6 id="连通图的宽度优先搜索算法"><a href="#连通图的宽度优先搜索算法" class="headerlink" title="连通图的宽度优先搜索算法"></a>连通图的宽度优先搜索算法</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Fun&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Matrix&lt;<span class="type">bool</span>&gt; &amp;G, <span class="type">int</span> v, vector&lt;<span class="type">bool</span>&gt; &amp;Visited, Fun Visit)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n = G.<span class="built_in">rows</span>();</span><br><span class="line"> 	queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"> 	<span class="built_in">Visit</span>(v), Visited[v] = <span class="number">1</span>, Q.<span class="built_in">push</span>(v);  <span class="comment">// Visit函数代表进行访问操作，数组Visited记录元素元素是否被访问</span></span><br><span class="line"> 	<span class="keyword">while</span>(<span class="keyword">not</span> Q.<span class="built_in">empty</span>())&#123; </span><br><span class="line">        v = Q.<span class="built_in">front</span>(), Q.<span class="built_in">pop</span>();</span><br><span class="line"> 		<span class="keyword">for</span>(<span class="type">int</span> w = <span class="number">0</span>; w &lt; n; ++w)</span><br><span class="line"> 			<span class="keyword">if</span>(<span class="keyword">not</span> Visited[w] <span class="keyword">and</span> <span class="built_in">G</span>(v, w) == <span class="number">1</span>)</span><br><span class="line"> 				<span class="built_in">Visit</span>(w), Visited[w] = <span class="number">1</span>, Q.<span class="built_in">push</span>(w);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 和树的层次遍历一模一样，区别就是树一般为二叉树，只有两个子节点，但是图是每个节点都有可能相连；</span></span><br><span class="line"><span class="comment">// 所以在宽度搜索时是将没有访问过的一排节点（相连）全部入队。</span></span><br></pre></td></tr></table></figure>

<h6 id="连通图的深度优先算法"><a href="#连通图的深度优先算法" class="headerlink" title="连通图的深度优先算法"></a>连通图的深度优先算法</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Fun&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Matrix&lt;<span class="type">bool</span>&gt; &amp;G, <span class="type">int</span> v, vector&lt;<span class="type">bool</span>&gt; &amp;Visited, Fun Visit)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n = G.<span class="built_in">rows</span>();</span><br><span class="line"> 	<span class="built_in">Visit</span>(v), Visited[v] = <span class="number">1</span>;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> w = <span class="number">0</span>; w &lt; n; ++w)</span><br><span class="line"> 		<span class="keyword">if</span>(<span class="keyword">not</span> Visited[w] <span class="keyword">and</span> <span class="built_in">G</span>(v, w) == <span class="number">1</span>)</span><br><span class="line"> 			<span class="built_in">DFS</span>(G, w, Visited, Visit);  <span class="comment">// 递归去寻找未访问的节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="二叉树的深度优先搜索（改）计算每个节点的深度"><a href="#二叉树的深度优先搜索（改）计算每个节点的深度" class="headerlink" title="二叉树的深度优先搜索（改）计算每个节点的深度"></a>二叉树的深度优先搜索（改）计算每个节点的深度</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BtNode</span></span><br><span class="line">&#123; </span><br><span class="line">    T data;</span><br><span class="line"> 	<span class="type">int</span> depth = <span class="number">1</span>;</span><br><span class="line"> 	BtNode *left = <span class="number">0</span>, *right = <span class="number">0</span>; <span class="comment">// 左子树, 右子树</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;  <span class="comment">// 使用后根遍历的方法计算深度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Depth</span><span class="params">(BtNode&lt;T&gt; *x)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> 	x-&gt;depth = std::<span class="built_in">max</span>(<span class="built_in">Depth</span>(x-&gt;left), <span class="built_in">Depth</span>(x-&gt;right)) + <span class="number">1</span>;  <span class="comment">// 递归向上回溯深度</span></span><br><span class="line"> 	<span class="keyword">return</span> x-&gt;depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="一般树的深度优先搜索（改）计算每个节点的层次"><a href="#一般树的深度优先搜索（改）计算每个节点的层次" class="headerlink" title="一般树的深度优先搜索（改）计算每个节点的层次"></a>一般树的深度优先搜索（改）计算每个节点的层次</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123; </span><br><span class="line">    T data;</span><br><span class="line"> 	<span class="type">int</span> level = <span class="number">1</span>;</span><br><span class="line"> 	TreeNode *first = <span class="number">0</span>, *next = <span class="number">0</span>;  <span class="comment">// first、next的作用类似于首位坐标</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;  <span class="comment">// 使用先根遍历的方法计算层次</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Level</span><span class="params">(TreeNode&lt;T&gt; *x, <span class="type">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"> 	x-&gt;level = level;  <span class="comment">// </span></span><br><span class="line"> 	<span class="keyword">for</span>(<span class="keyword">auto</span> w = x-&gt;first; w != <span class="number">0</span>; w = w-&gt;next)  <span class="comment">// 这里就是层次遍历的体现，将first开始到最后一个next节点</span></span><br><span class="line"> 		<span class="built_in">Level</span>(w, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="连通图的深度优先遍历算法（改）计算每个顶点的层次"><a href="#连通图的深度优先遍历算法（改）计算每个顶点的层次" class="headerlink" title="连通图的深度优先遍历算法（改）计算每个顶点的层次"></a>连通图的深度优先遍历算法（改）计算每个顶点的层次</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Matrix.hpp&quot;</span>  <span class="comment">// 图计算的依赖</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ios.hpp&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Level</span><span class="params">(<span class="type">const</span> Matrix&lt;<span class="type">bool</span>&gt; &amp;G, <span class="type">int</span> u = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n = G.<span class="built_in">rows</span>();</span><br><span class="line"> 	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(n, <span class="number">0</span>)</span></span>;  <span class="comment">// 设置L中有n个元素，每个元素值为0</span></span><br><span class="line"> 	function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;</span><br><span class="line"> 	Level = [&amp;](<span class="type">int</span> u, <span class="type">int</span> level)&#123;  <span class="comment">// 区别于外面一圈Level函数，可以调用外圈Level中的参数</span></span><br><span class="line">        L[u] = level;</span><br><span class="line"> 		<span class="keyword">for</span>(<span class="type">int</span> w = <span class="number">0</span>; w &lt; n; ++w)</span><br><span class="line"> 			<span class="keyword">if</span>(L[w] == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">G</span>(u, w) == <span class="number">1</span>)</span><br><span class="line"> 				<span class="built_in">Level</span>(w, level + <span class="number">1</span>);</span><br><span class="line"> 	&#125;;</span><br><span class="line"> 	<span class="built_in">Level</span>(u, <span class="number">1</span>);</span><br><span class="line"> 	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="图的宽度优先遍历算法（改）输出图的每个连通分支"><a href="#图的宽度优先遍历算法（改）输出图的每个连通分支" class="headerlink" title="图的宽度优先遍历算法（改）输出图的每个连通分支"></a>图的宽度优先遍历算法（改）输出图的每个连通分支</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../algorithm.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BFS</span><span class="params">(Matrix&lt;<span class="type">bool</span>&gt; &amp;G, <span class="type">int</span> v, vector&lt;<span class="type">bool</span>&gt; &amp;Visited)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n = G.<span class="built_in">rows</span>();</span><br><span class="line"> 	queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"> 	set&lt;<span class="type">int</span>&gt; part;</span><br><span class="line"> 	part &lt;&lt; v, Visited[v] = <span class="number">1</span>, Q.<span class="built_in">push</span>(v);</span><br><span class="line"> 	<span class="keyword">while</span>(<span class="keyword">not</span> Q.<span class="built_in">empty</span>())&#123; </span><br><span class="line">        v = Q.<span class="built_in">front</span>(), Q.<span class="built_in">pop</span>();</span><br><span class="line"> 		<span class="keyword">for</span>(<span class="type">int</span> w = <span class="number">0</span>; w &lt; n; ++w)</span><br><span class="line"> 			<span class="keyword">if</span>(<span class="keyword">not</span> Visited[w] <span class="keyword">and</span> <span class="built_in">G</span>(v, w) == <span class="number">1</span>)</span><br><span class="line"> 				part &lt;&lt; w, Visited[w] = <span class="number">1</span>, Q.<span class="built_in">push</span>(w);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	<span class="keyword">return</span> part;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BFT</span><span class="params">(Matrix&lt;<span class="type">bool</span>&gt; &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n = G.<span class="built_in">rows</span>();</span><br><span class="line"> 	<span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">Visited</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"> 	vector&lt;set&lt;<span class="type">int</span>&gt;&gt; parts;  <span class="comment">// 创建一个动态大小的数组parts记录int集合</span></span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; ++v)</span><br><span class="line"> 		<span class="keyword">if</span>(<span class="keyword">not</span> Visited[v])</span><br><span class="line"> 			parts &lt;&lt; <span class="built_in">BFS</span>(G, v, Visited);  <span class="comment">// 将每个节点都遍历一遍</span></span><br><span class="line"> 	<span class="keyword">return</span> parts;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 和连通图的主要差别就是BFT函数将所有节点扫一遍，避免出现有些节点单出来的情况。</span></span><br><span class="line"><span class="comment">//[1,1,1,0,0],</span></span><br><span class="line"><span class="comment">//[1,1,1,0,0],</span></span><br><span class="line"><span class="comment">//[1,1,1,0,0],</span></span><br><span class="line"><span class="comment">//[0,0,0,1,1],</span></span><br><span class="line"><span class="comment">//[0,0,0,1,1]</span></span><br></pre></td></tr></table></figure>



<h2 id="分治方法"><a href="#分治方法" class="headerlink" title="分治方法"></a>分治方法</h2><h6 id="折半搜索（升序数组）"><a href="#折半搜索（升序数组）" class="headerlink" title="折半搜索（升序数组）"></a>折半搜索（升序数组）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从一个升序数组中查找一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(T X[], <span class="type">int</span> n, <span class="type">const</span> T2 &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   	<span class="type">int</span> low = <span class="number">0</span>, up = n;</span><br><span class="line"> 	<span class="keyword">while</span>(low &lt; up)&#123; </span><br><span class="line">        <span class="type">int</span> m = (low + up) / <span class="number">2</span>;</span><br><span class="line"> 		<span class="keyword">if</span>(v == X[m]) <span class="keyword">return</span> m;</span><br><span class="line"> 		<span class="keyword">else</span> <span class="keyword">if</span>(v &lt; X[m]) up = m;</span><br><span class="line"> 		<span class="keyword">else</span> low = m + <span class="number">1</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 时间复杂度为O(log(n))</span></span><br></pre></td></tr></table></figure>

<h6 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(T W[], <span class="type">int</span> low, <span class="type">int</span> m, <span class="type">int</span> up)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">vector <span class="title">X</span><span class="params">(W + low, W + m)</span></span>;  <span class="comment">// 创建动态数组X长度为low~m，存入low~m的数据</span></span><br><span class="line"> 	<span class="function">vector <span class="title">Y</span><span class="params">(W + m, W + up)</span></span>;  <span class="comment">// 创建动态数组Y长度为m~up，存入m~up的数据</span></span><br><span class="line"> 	<span class="type">int</span> nx = <span class="built_in">size</span>(X), ny = <span class="built_in">size</span>(Y);</span><br><span class="line"> 	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = low;</span><br><span class="line"> 	<span class="keyword">while</span>(i &lt; nx <span class="keyword">and</span> j &lt; ny)  <span class="comment">// 将X、Y中数据进行比较，存入W数组</span></span><br><span class="line"> 		<span class="keyword">if</span>(X[i] &lt; Y[j])</span><br><span class="line"> 			W[k] = X[i], ++k, ++i;</span><br><span class="line"> 		<span class="keyword">else</span></span><br><span class="line"> 			W[k] = Y[j], ++k, ++j;</span><br><span class="line"> 	<span class="keyword">while</span>(i &lt; nx)  <span class="comment">// 将比较完后未存入的元素存入</span></span><br><span class="line"> 		W[k] = X[i], ++k, ++i;</span><br><span class="line"> 	<span class="keyword">while</span>(j &lt; ny)</span><br><span class="line"> 		W[k] = Y[j], ++k, ++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(T X[], <span class="type">int</span> low, <span class="type">int</span> up)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(up - low &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> 	<span class="type">int</span> m = (low + up) / <span class="number">2</span>;</span><br><span class="line"> 	<span class="built_in">MergeSort</span>(X, low, m);  <span class="comment">// 左右递归再向上排序</span></span><br><span class="line"> 	<span class="built_in">MergeSort</span>(X, m, up);</span><br><span class="line"> 	<span class="built_in">Merge</span>(X, low, m, up);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 时间复杂度为Θ(n * log(n))</span></span><br></pre></td></tr></table></figure>

<h6 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(T X[], <span class="type">int</span> low, <span class="type">int</span> up)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> key = up - <span class="number">1</span>, p = low;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = low; i &lt; key; ++i)  <span class="comment">// 每次将比最后一个数小的数排到数组的前面</span></span><br><span class="line"> 		<span class="keyword">if</span>(X[i] &lt; X[key])</span><br><span class="line"> 			<span class="built_in">swap</span>(X[i], X[p]), ++p;</span><br><span class="line"> 	<span class="built_in">swap</span>(X[key], X[p]);  <span class="comment">// 如果前面所有数都比X[key]小，那么swap(X[key], X[p])实际为swap(X[key], X[key])</span></span><br><span class="line"> 	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(T X[], <span class="type">int</span> low, <span class="type">int</span> up)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(up - low &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> 	<span class="type">int</span> m = <span class="built_in">Partition</span>(X, low, up);</span><br><span class="line"> 	<span class="built_in">QuickSort</span>(X, low, m);  <span class="comment">// 不断缩小左右区间，直到完成排序</span></span><br><span class="line"> 	<span class="built_in">QuickSort</span>(X, m + <span class="number">1</span>, up);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 平均时间复杂度为O(n * log(n))，最坏时间复杂度为O(n ^ 2)</span></span><br></pre></td></tr></table></figure>

<h6 id="线性时间选择算法"><a href="#线性时间选择算法" class="headerlink" title="线性时间选择算法"></a>线性时间选择算法</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(T X[], <span class="type">int</span> low, <span class="type">int</span> up)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> key = up - <span class="number">1</span>, p = low;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = low; i &lt; key; ++i)</span><br><span class="line"> 		<span class="keyword">if</span>(X[i] &lt; X[key])</span><br><span class="line"> 			<span class="built_in">swap</span>(X[i], X[p]), ++p;</span><br><span class="line"> 	<span class="built_in">swap</span>(X[key], X[p]);</span><br><span class="line"> 	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T &amp;<span class="title">Select</span><span class="params">(T X[], <span class="type">int</span> n, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, up = n;</span><br><span class="line"> 	<span class="keyword">for</span>(;;)&#123; </span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">Partition</span>(X, low, up);</span><br><span class="line"> 		<span class="keyword">if</span>(k == m) <span class="keyword">return</span> X[m];  <span class="comment">// 找到指定元素，算法终止</span></span><br><span class="line"> 		<span class="keyword">else</span> <span class="keyword">if</span>(k &lt; m) up = m;</span><br><span class="line"> 		<span class="keyword">else</span> low = m + <span class="number">1</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 平均时间复杂度为O(n)，最坏时间复杂度为O(n ^ 2)</span></span><br><span class="line"><span class="comment">// 显而易见，这里的Partition函数和上题的一模一样，因此最坏情况（数组降序）时时间复杂度为O(n ^ 2)</span></span><br><span class="line"><span class="comment">// 这个算法主要是用来在乱序数组中寻找指定元素</span></span><br></pre></td></tr></table></figure>

<h6 id="合并数组（不含重复元素）"><a href="#合并数组（不含重复元素）" class="headerlink" title="合并数组（不含重复元素）"></a>合并数组（不含重复元素）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Merge</span><span class="params">(T X[], <span class="type">int</span> m, T Y[], <span class="type">int</span> n, T W[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line"> 	<span class="keyword">while</span>(i &lt; m <span class="keyword">and</span> j &lt; n)</span><br><span class="line"> 		<span class="keyword">if</span>(X[i] &lt; Y[j])</span><br><span class="line"> 			W[k] = X[i], ++k, ++i;</span><br><span class="line"> 		<span class="keyword">else</span> <span class="keyword">if</span>(X[i] &gt; Y[j])</span><br><span class="line"> 			W[k] = Y[j], ++k, ++j;</span><br><span class="line"> 		<span class="keyword">else</span></span><br><span class="line"> 			W[k] = X[i], ++k, ++i, ++j;</span><br><span class="line"> 	<span class="keyword">while</span>(i &lt; m)</span><br><span class="line"> 		W[k] = X[i], ++k, ++i;</span><br><span class="line"> 	<span class="keyword">while</span>(j &lt; n)</span><br><span class="line"> 		W[k] = Y[j], ++k, ++j;</span><br><span class="line"> 	<span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 和归并排序的merge函数基本一模一样，就不做赘述</span></span><br></pre></td></tr></table></figure>

<h6 id="奇偶划分"><a href="#奇偶划分" class="headerlink" title="奇偶划分"></a>奇偶划分</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span> X[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"> 		<span class="keyword">if</span>(X[i] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line"> 			<span class="built_in">swap</span>(X[i], X[p]), ++p;</span><br><span class="line"> 	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h6 id="装载问题"><a href="#装载问题" class="headerlink" title="装载问题"></a>装载问题</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">Load</span><span class="params">(vector&lt;<span class="type">double</span>&gt; &amp;W, <span class="type">double</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n = W.<span class="built_in">size</span>();</span><br><span class="line"> 	<span class="built_in">sort</span>(<span class="built_in">begin</span>(W), <span class="built_in">end</span>(W));  <span class="comment">// 从小到大排序</span></span><br><span class="line"> 	<span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">X</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"> 	<span class="type">double</span> rc = M;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n <span class="keyword">and</span> W[i] &lt;= rc; ++i)</span><br><span class="line"> 		X[i] = <span class="number">1</span>, rc -= W[i];</span><br><span class="line"> 	<span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(vector&lt;<span class="type">double</span>&gt; &amp;V, vector&lt;<span class="type">double</span>&gt; &amp;W)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">oType</span> &#123; <span class="type">double</span> v, w; &#125;;  <span class="comment">// 一个物品具有价值、重量两个属性</span></span><br><span class="line"> 	<span class="keyword">auto</span> cmp = [](oType p, oType q)&#123; </span><br><span class="line">        <span class="keyword">return</span> p.v / p.w &gt; q.v / q.w;</span><br><span class="line"> 	&#125;;</span><br><span class="line"> 	<span class="type">int</span> n = <span class="built_in">min</span>(V.<span class="built_in">size</span>(), W.<span class="built_in">size</span>());</span><br><span class="line"> 	<span class="function">vector&lt;oType&gt; <span class="title">X</span><span class="params">(n)</span></span>;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"> 		X[i] = &#123;V[i], W[i]&#125;;</span><br><span class="line"> 	<span class="built_in">sort</span>(<span class="built_in">begin</span>(X), <span class="built_in">end</span>(X), cmp);  <span class="comment">// 这个可能是按照cmp规则对X进行排序（题主C++不太好QWQ）</span></span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"> 		V[i] = X[i].v, W[i] = X[i].w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">Knap</span><span class="params">(vector&lt;<span class="type">double</span>&gt; &amp;V, vector&lt;<span class="type">double</span>&gt; &amp;W, <span class="type">double</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">min</span>(V.<span class="built_in">size</span>(), W.<span class="built_in">size</span>());  <span class="comment">// 避免出现价值、重量不同导致物品个数出问题</span></span><br><span class="line"> 	<span class="built_in">Sort</span>(V, W);</span><br><span class="line"> 	<span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">X</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"> 	<span class="type">double</span> rc = M;</span><br><span class="line"> 	<span class="type">int</span> t;</span><br><span class="line"> 	<span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; n <span class="keyword">and</span> W[t] &lt;= rc; ++t)</span><br><span class="line"> 		X[t] = <span class="number">1</span>, rc -= W[t];</span><br><span class="line"> 	<span class="keyword">if</span>(t &lt; n)  <span class="comment">// 这一步很多余，毕竟不可能只把一个物品放一部分进背包</span></span><br><span class="line"> 		X[t] = rc / W[t];</span><br><span class="line"> 	<span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Knap函数在Sort函数下部分与装载问题无异，因此Sort函数主要是将价值/重量进行排序</span></span><br></pre></td></tr></table></figure>

<h6 id="活动安排问题"><a href="#活动安排问题" class="headerlink" title="活动安排问题"></a>活动安排问题</h6><p>已知n个活动E &#x3D; {1，2，…，n}需要使用同一资源，第k个活动的开始和结束时间分别是s_k和f_k，其中s_k &lt; f_k, k &#x3D; 1，2，…，n。</p>
<p>简单来说就是一个集合中有若干元素，每个元素含有起始（s_k）、结束（f_k）两个值，只有在起始时间才能开始，占用资源直到结束时间结束，经历了起始和结束的元素才能进入子集。求这个集合中能完成的最大子集。</p>
<p>贪心思想就是当一个活动结束立即找到一个活动开始，优先找到结束时间早的活动。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(vector&lt;<span class="type">double</span>&gt; &amp;S, vector&lt;<span class="type">double</span>&gt; &amp;F)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">oType</span> &#123; <span class="type">double</span> s, f; &#125;;</span><br><span class="line"> 	<span class="keyword">auto</span> cmp = [](oType p, oType q)&#123; </span><br><span class="line">        <span class="keyword">return</span> p.f &lt; q.f;  <span class="comment">// 按照结束时间进行排序</span></span><br><span class="line"> 	&#125;;</span><br><span class="line"> 	<span class="type">int</span> n = <span class="built_in">min</span>(S.<span class="built_in">size</span>(), F.<span class="built_in">size</span>());</span><br><span class="line"> 	<span class="function">vector&lt;oType&gt; <span class="title">X</span><span class="params">(n)</span></span>;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"> 		X[i] = &#123;S[i], F[i]&#125;;</span><br><span class="line"> 	<span class="built_in">sort</span>(<span class="built_in">begin</span>(X), <span class="built_in">end</span>(X), cmp);</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"> 		S[i] = X[i].s, F[i] = X[i].f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">Action</span><span class="params">(vector&lt;<span class="type">double</span>&gt; &amp;S, vector&lt;<span class="type">double</span>&gt; &amp;F)</span>  <span class="comment">// S是起始时间数组；F是结束时间数组（Start/Final）</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">min</span>(S.<span class="built_in">size</span>(), F.<span class="built_in">size</span>());</span><br><span class="line"> 	<span class="built_in">Sort</span>(S, F);</span><br><span class="line"> 	<span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">X</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"> 	X[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"> 		<span class="keyword">if</span>(S[i] &gt;= F[j])</span><br><span class="line"> 			X[i] = <span class="number">1</span>, j = i;</span><br><span class="line"> 	<span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主体和背包问题类似，明确两者的贪心条件区别，可以同时记忆</span></span><br></pre></td></tr></table></figure>

<h6 id="最小生成树Prim算法"><a href="#最小生成树Prim算法" class="headerlink" title="最小生成树Prim算法"></a>最小生成树Prim算法</h6><p>从图的任一节点开始，每次找到与该节点连通的最短路径的节点（未被访问），直到遍历完所有节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .assign()：C++ string类的成员函数，用于拷贝、赋值操作，它们允许我们顺次地把一个string 对象的部分内容拷贝到另一个string 对象上。</span></span><br><span class="line"><span class="comment">// isinf()函数是cmath标头的库函数，用于检查给定值是否为无限(负无穷大或正无穷大)。如果给定值是无穷大，则返回1；否则，返回0。 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Prim</span><span class="params">(<span class="type">const</span> Matrix&lt;<span class="type">double</span>&gt; &amp;G, <span class="type">int</span> v, vector&lt;<span class="type">int</span>&gt; &amp;prev)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n = G.<span class="built_in">rows</span>();</span><br><span class="line"> 	prev.<span class="built_in">assign</span>(n, v); <span class="comment">// prev保存各节点的父亲，初始为根v（这里不写0是因为可能你设置的起始节点不是0）</span></span><br><span class="line"> 	<span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">S</span><span class="params">(n, <span class="literal">false</span>)</span></span>;  <span class="comment">// 记录节点是否被选，初始值为false</span></span><br><span class="line"> 	S[v] = <span class="literal">true</span>;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)&#123; </span><br><span class="line">        <span class="type">double</span> min = INFINITY;</span><br><span class="line"> 		<span class="keyword">for</span>(<span class="type">int</span> w = <span class="number">0</span>; w &lt; n; ++w)</span><br><span class="line"> 			<span class="keyword">if</span>(<span class="keyword">not</span> S[w] <span class="keyword">and</span> <span class="built_in">G</span>(prev[w], w) &lt; min) </span><br><span class="line">                min = <span class="built_in">G</span>(prev[w], w), v = w;  <span class="comment">// 找到与节点相邻的最短边</span></span><br><span class="line"> 		<span class="keyword">if</span>(<span class="built_in">isinf</span>(min)) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 判断节点间是否连通</span></span><br><span class="line"> 		S[v] = <span class="literal">true</span>;</span><br><span class="line"> 		<span class="keyword">for</span>(<span class="type">int</span> w = <span class="number">0</span>; w &lt; n; ++w)</span><br><span class="line"> 			<span class="keyword">if</span>(<span class="keyword">not</span> S[w] <span class="keyword">and</span> <span class="built_in">G</span>(v, w) &lt; <span class="built_in">G</span>(prev[w], w))  <span class="comment">// 更新未选顶点的父亲）</span></span><br><span class="line">                prev[w] = v;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该题主要用于判断无向图是否连通</span></span><br></pre></td></tr></table></figure>

<h6 id="最小生成树Kruskal算法"><a href="#最小生成树Kruskal算法" class="headerlink" title="最小生成树Kruskal算法"></a>最小生成树Kruskal算法</h6><p>将节点之间的边按照升序排列，选取最短边，在不形成环的情况下遍历完所有节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Kruskal</span><span class="params">(vector&lt;Edge&gt; &amp;Ed, <span class="type">int</span> n, vector&lt;Edge&gt; &amp;X)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(Ed.<span class="built_in">size</span>() &lt; n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 边数比节点个数少不可能连通</span></span><br><span class="line"> 	<span class="built_in">sort</span>(<span class="built_in">begin</span>(Ed), <span class="built_in">end</span>(Ed));</span><br><span class="line"> 	<span class="function">UnionFind <span class="title">U</span><span class="params">(n)</span></span>;  <span class="comment">// 并查集结构，初始将每个节点作为一个子树</span></span><br><span class="line"> 	X = &#123;&#125;;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="keyword">auto</span> e : Ed)&#123; </span><br><span class="line">        <span class="type">int</span> u = U.<span class="built_in">Find</span>(e.u), v = U.<span class="built_in">Find</span>(e.v);</span><br><span class="line"> 		<span class="keyword">if</span>(u == v) <span class="keyword">continue</span>;  <span class="comment">// 两节点是一个分支的，不用合并直接进入下一个节点判别</span></span><br><span class="line"> 		U.<span class="built_in">Union</span>(u, v);</span><br><span class="line"> 		X.<span class="built_in">push_back</span>(e);  <span class="comment">// 记录节点e已被使用</span></span><br><span class="line"> 		<span class="keyword">if</span>(X.<span class="built_in">size</span>() &gt;= n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h6 id="多机调度问题"><a href="#多机调度问题" class="headerlink" title="多机调度问题"></a>多机调度问题</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Machine</span> &#123; <span class="type">int</span> i, tm; &#125;; <span class="comment">// 机器号, 使用时间</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Machine &amp;x, <span class="type">const</span> Machine &amp;y)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> x.tm &lt; y.tm; <span class="comment">// 比较使用时间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">InitMachine</span><span class="params">(<span class="type">int</span> m)</span> <span class="comment">// 初始化机器和最小堆</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    minheap&lt;Machine&gt; H;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line"> 		H.<span class="built_in">push</span>(&#123;i, <span class="number">0</span>&#125;);</span><br><span class="line"> 	<span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LPT</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;J, <span class="type">int</span> m)</span> <span class="comment">// n是作业数, m是机器数, n&gt;m</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">begin</span>(J), <span class="built_in">end</span>(J)); <span class="comment">// 作业按照所需处理时间升序排列</span></span><br><span class="line"> 	<span class="keyword">auto</span> H = <span class="built_in">InitMachine</span>(m); <span class="comment">// 初始化机器和最小堆</span></span><br><span class="line"> 	<span class="type">int</span> n = J.<span class="built_in">size</span>(); <span class="comment">// 作业数</span></span><br><span class="line"> 	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">X</span><span class="params">(n)</span></span>; <span class="comment">// 当前调度</span></span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> t = n - <span class="number">1</span>; t &gt;= <span class="number">0</span>; --t) <span class="comment">// 从处理时间最长的作业开始</span></span><br><span class="line"> 	&#123; </span><br><span class="line">        <span class="keyword">auto</span> [i, tm] = H.<span class="built_in">top</span>(); H.<span class="built_in">pop</span>(); <span class="comment">// 选用最早空闲的机器</span></span><br><span class="line"> 		X[t] = i, tm += J[t]; <span class="comment">// 作业t安排到机器i</span></span><br><span class="line"> 		H.<span class="built_in">push</span>(&#123;i, tm&#125;);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为这题代码过长，强行理解不如按照自己的思路去写一个全新的，所以对于参考代码不做过多赘述。</span></span><br></pre></td></tr></table></figure>

<p>多级调度问题主要是n个机器、m个作业，每个作业用时不等（可以相等），求最短调度时间。</p>
<p>整体思路（仅供参考）：</p>
<p>（1）将作业调度时间降序排列；（2）找到当前时间最短的机器插入作业；（3）判断下一个作业。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> T[])</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n];  <span class="comment">// 记录各机器调度时间</span></span><br><span class="line">    Arrays.sort(T,Collections.reverseOrder());  <span class="comment">// 降序排列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> INFINITY;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pom</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; min)&#123;</span><br><span class="line">                min = a[j];</span><br><span class="line">                pom = j;  <span class="comment">// 记录最短调度机器下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[pom] += m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;  <span class="comment">// 找出所有机器中耗时最长的那个</span></span><br><span class="line">        <span class="keyword">if</span>(max &lt; a[i])</span><br><span class="line">            max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h2><h6 id="矩阵连乘最优次序"><a href="#矩阵连乘最优次序" class="headerlink" title="矩阵连乘最优次序"></a>矩阵连乘最优次序</h6><p>主要是n个矩阵进行矩阵乘法运算时，通过括号改变运算的先后顺序，减少运算次数，找到最佳划分方法，求解最少运算次数.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Matrix&lt;<span class="type">int</span>&gt; <span class="title">MatrixChain</span><span class="params">(<span class="type">int</span> r[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">Matrix&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n, n, <span class="number">0</span>)</span>, <span class="title">kay</span><span class="params">(n, n)</span></span>;  <span class="comment">// c(i, j)存储矩阵i连乘矩阵j中的最小值，kay记录分段位置</span></span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)&#123;  <span class="comment">// 第一层循环从链末尾向前保存最优路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123; </span><br><span class="line">            <span class="built_in">c</span>(i, j) = (<span class="type">int</span>)INFINITY;  <span class="comment">// 初始连乘大小默认最大</span></span><br><span class="line"> 			<span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt; j; ++k)&#123; </span><br><span class="line">                <span class="type">int</span> t = <span class="built_in">c</span>(i, k) + <span class="built_in">c</span>(k + <span class="number">1</span>, j) + r[i] * r[k + <span class="number">1</span>] * r[j + <span class="number">1</span>];</span><br><span class="line"> 				<span class="keyword">if</span>(t &lt; <span class="built_in">c</span>(i, j)) <span class="built_in">c</span>(i, j) = t, <span class="built_in">kay</span>(i, j) = k;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> kay;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 时间复杂度为O(n ^ 3)</span></span><br><span class="line"><span class="comment">// 关于这题其实有些费解，因为矩阵能够连乘，因此可以近似看成一条链。具体我也说不很清，题主也是让别人教的QWQ</span></span><br></pre></td></tr></table></figure>

<h6 id="任意顶点间最短路径长度"><a href="#任意顶点间最短路径长度" class="headerlink" title="任意顶点间最短路径长度"></a>任意顶点间最短路径长度</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Matrix&lt; <span class="type">double</span>&gt; <span class="title">Floyd</span><span class="params">(<span class="type">const</span> Matrix&lt;<span class="type">double</span>&gt; &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n = G.<span class="built_in">rows</span>();</span><br><span class="line"> 	<span class="keyword">auto</span> A = G;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++k)  <span class="comment">// 第一层循环中的k作为中间节点</span></span><br><span class="line"> 		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)  <span class="comment">// 二、三层分别为起始节点和终止节点</span></span><br><span class="line"> 			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123; </span><br><span class="line">                <span class="keyword">auto</span> t = <span class="built_in">A</span>(i, k) + <span class="built_in">A</span>(k, j);  <span class="comment">// 在这里将首尾相连，去除k</span></span><br><span class="line"> 				<span class="keyword">if</span>(t &lt; <span class="built_in">A</span>(i, j)) </span><br><span class="line">                    <span class="built_in">A</span>(i, j) = t;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 时间复杂度为O(n ^ 3)</span></span><br><span class="line"><span class="comment">// 这个算法是直接将所有节点到任一节点的路径直接算出来了，如果要算任意节点可以直接找到结果</span></span><br></pre></td></tr></table></figure>

<h6 id="多段图"><a href="#多段图" class="headerlink" title="多段图"></a>多段图</h6><ul>
<li>多段图是一个带权有向图并且无环</li>
<li>有且仅有一个起始点（原点source）和一个终止节点（汇点target）</li>
<li>它有n个阶段，每个阶段由特定的几个结点构成</li>
<li>每个结点的所有结点都只能指向下一个相邻的阶段，阶段之间不能越界(大概长这样)</li>
</ul>
<p><img src="/2022/06/12/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/%E5%A4%9A%E6%AE%B5%E5%9B%BE.png" alt="多段图"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">MultiGraph</span><span class="params">(<span class="type">const</span> Matrix&lt;<span class="type">double</span>&gt; &amp;G, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n = G.<span class="built_in">rows</span>(), t = n - <span class="number">1</span>;  <span class="comment">// n顶点数，t汇点（不包含起始点的中继点）</span></span><br><span class="line"> 	<span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">C</span><span class="params">(n, <span class="number">0</span>)</span></span>;  <span class="comment">// C[j]记录从初始节点到汇点的距离，初始为0</span></span><br><span class="line"> 	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Next</span><span class="params">(n)</span></span>;  <span class="comment">// Next记录最短路径上所经过的后继节点</span></span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> j = t - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)&#123;  <span class="comment">// 从终点向前计算</span></span><br><span class="line">        <span class="type">int</span> r = j + <span class="number">1</span>;</span><br><span class="line"> 		<span class="keyword">for</span>(<span class="type">int</span> i = r; i &lt; n; ++i)</span><br><span class="line"> 			<span class="keyword">if</span>(<span class="built_in">G</span>(j, i) + C[i] &lt; <span class="built_in">G</span>(j, r) + C[r]) </span><br><span class="line">                r = i;</span><br><span class="line"> 		C[j] = <span class="built_in">G</span>(j, r) + C[r], Next[j] = r;  <span class="comment">// 存入当前节点到终点的最短路径，并且更新当前节点的后继节点</span></span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">X</span><span class="params">(m)</span></span>;</span><br><span class="line"> 	X[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i)  <span class="comment">// 将后继节点转为从起点开始的正向顺序</span></span><br><span class="line"> 		X[i] = Next[X[i - <span class="number">1</span>]];</span><br><span class="line"> 	<span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 时间复杂度为O(n ^ 2)</span></span><br></pre></td></tr></table></figure>

<h6 id="两个字符串的最长公共子串"><a href="#两个字符串的最长公共子串" class="headerlink" title="两个字符串的最长公共子串"></a>两个字符串的最长公共子串</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Matrix&lt;<span class="type">int</span>&gt; <span class="title">LCSSize</span><span class="params">(<span class="type">const</span> string &amp;X, <span class="type">const</span> string &amp;Y)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> m = X.<span class="built_in">size</span>(), n = Y.<span class="built_in">size</span>();</span><br><span class="line"> 	<span class="function">Matrix&lt;<span class="type">int</span>&gt; <span class="title">C</span><span class="params">(m + <span class="number">1</span>, n + <span class="number">1</span>)</span></span>;  <span class="comment">// 构建一个(m + 1, n + 1)大小的矩阵（从1开始，防止越界）</span></span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)</span><br><span class="line"> 		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++j)</span><br><span class="line"> 			<span class="keyword">if</span>(i &lt;= <span class="number">0</span> <span class="keyword">or</span> j &lt;= <span class="number">0</span>)</span><br><span class="line"> 				<span class="built_in">C</span>(i, j) = <span class="number">0</span>;</span><br><span class="line"> 			<span class="keyword">else</span> <span class="keyword">if</span>(X[i - <span class="number">1</span>] == Y[j - <span class="number">1</span>])</span><br><span class="line"> 				<span class="built_in">C</span>(i, j) = <span class="built_in">C</span>(i - <span class="number">1</span>, j - <span class="number">1</span>) + <span class="number">1</span>;  <span class="comment">// 计数代表公共子串有几个元素</span></span><br><span class="line"> 			<span class="keyword">else</span></span><br><span class="line"> 				<span class="built_in">C</span>(i, j) = <span class="built_in">max</span>(<span class="built_in">C</span>(i - <span class="number">1</span>, j), <span class="built_in">C</span>(i, j - <span class="number">1</span>));  <span class="comment">// 从当前位置的上方或者左边选取较大值填充不相等区域</span></span><br><span class="line"> 	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">LCS</span><span class="params">(<span class="type">const</span> string &amp;X, <span class="type">const</span> string &amp;Y)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">LCSSize</span>(X, Y);</span><br><span class="line"> 	<span class="type">int</span> i = X.<span class="built_in">size</span>(), j = Y.<span class="built_in">size</span>(), k = <span class="built_in">C</span>(i, j);  <span class="comment">// k代表最长子串元素个数</span></span><br><span class="line"> 	string Z;</span><br><span class="line"> 	<span class="keyword">while</span>(k &gt; <span class="number">0</span>)</span><br><span class="line"> 		<span class="keyword">if</span>(X[i - <span class="number">1</span>] == Y[j - <span class="number">1</span>])  <span class="comment">// 相等，矩阵脱最外层</span></span><br><span class="line"> 			Z.<span class="built_in">push_back</span>(X[i - <span class="number">1</span>]), --i, --j, --k;</span><br><span class="line"> 		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">C</span>(i, j) == <span class="built_in">C</span>(i - <span class="number">1</span>, j)) --i;</span><br><span class="line"> 		<span class="keyword">else</span> --j;</span><br><span class="line"> 	<span class="built_in">reverse</span>(<span class="built_in">begin</span>(Z), <span class="built_in">end</span>(Z));  <span class="comment">// 反转</span></span><br><span class="line"> 	<span class="keyword">return</span> Z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 时间复杂度为O(mn)，其中m=|X|, n=|Y|</span></span><br></pre></td></tr></table></figure>

<h6 id="0-x2F-1背包问题"><a href="#0-x2F-1背包问题" class="headerlink" title="0&#x2F;1背包问题"></a>0&#x2F;1背包问题</h6><p>一共有N件物品，每件物品都有其相应的体积和价值，给你一个背包，背包有容量上限，怎样往背包中装物品，能让背包中的物品价值最高。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;map&lt;<span class="type">double</span>, <span class="type">double</span>&gt;&gt; RestType;  <span class="comment">// 剩余表, 剩余容量-最优效益对数组</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Knap</span><span class="params">(vector&lt;<span class="type">double</span>&gt; &amp;V, vector&lt;<span class="type">double</span>&gt; &amp;W, <span class="type">double</span> c)</span>  <span class="comment">// 效益数组, 重量数组, 容量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="type">int</span> n = <span class="built_in">min</span>(V.<span class="built_in">size</span>(), W.<span class="built_in">size</span>()); <span class="comment">// 物品数</span></span><br><span class="line"> 	<span class="function">RestType <span class="title">M</span><span class="params">(n)</span></span>; <span class="comment">// 剩余容量-最优效益对数组</span></span><br><span class="line"> 	function&lt;<span class="type">double</span>(<span class="type">int</span>, <span class="type">double</span>)&gt; m = [&amp;](<span class="type">int</span> i, <span class="type">double</span> y)&#123; </span><br><span class="line">        <span class="keyword">if</span>(M[i].<span class="built_in">count</span>(y) &gt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> M[i][y]; <span class="comment">// 已经计算过, 返回</span></span><br><span class="line"> 		<span class="type">double</span> cv; <span class="comment">// 否则, 开始递归计算</span></span><br><span class="line"> 		<span class="keyword">if</span>(i &gt;= n - <span class="number">1</span> <span class="keyword">and</span> W[i] &gt; y) </span><br><span class="line">            cv = <span class="number">0</span>;</span><br><span class="line"> 		<span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= n - <span class="number">1</span>) </span><br><span class="line">            cv = V[i];</span><br><span class="line"> 		<span class="keyword">else</span> <span class="keyword">if</span>(W[i] &gt; y) </span><br><span class="line">            cv = <span class="built_in">m</span>(i + <span class="number">1</span>, y);</span><br><span class="line"> 		<span class="keyword">else</span> </span><br><span class="line">            cv = <span class="built_in">max</span>(<span class="built_in">m</span>(i + <span class="number">1</span>, y), <span class="built_in">m</span>(i + <span class="number">1</span>, y - W[i]) + V[i]);</span><br><span class="line"> 		M[i][y] = cv;</span><br><span class="line"> 		<span class="keyword">return</span> M[i][y];</span><br><span class="line"> 	&#125;;  <span class="comment">// 调用m(0, c)耗时O(n^2 * 2^n)</span></span><br><span class="line"> 	<span class="keyword">auto</span> fv = <span class="built_in">m</span>(<span class="number">0</span>, c);</span><br><span class="line"> 	<span class="keyword">return</span> M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题主表示比较嫌弃这种写法，和众所周知的AcWing上的解法差别还挺大的，因为这只是整体算法的一部分，理解起来反而很困难，但是如果要你把整个算法全部写出来，这样的写法一定非常鸡肋，所以下面是题主的代码，其实是取巧了，不像如上代码一样具有普适性，但是胜在容易理解和比较好写（<del>对我来说</del>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Solution</span><span class="params">(<span class="type">int</span> v[], <span class="type">int</span> w[], <span class="type">int</span> c)</span>&#123;  <span class="comment">// 效益数组, 重量数组, 容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Math.max(v.length, w.length);  <span class="comment">// 物品数</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][c + <span class="number">1</span>];  <span class="comment">// dp记录背包内选择后的最大价值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= n;i++)&#123;  <span class="comment">// 枚举所有背包占用的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= c;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j - w[i] &gt;=<span class="number">0</span>)</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[j]] + v[i]);  <span class="comment">// 将第i件物品放入背包的效益与不放入背包的效益进行比较，决定第i件物品是否放入背包。</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][max];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样子只能输出背包最大效益，如果想要知道选取的是哪些元素的话，要么还是参照老师的那种写法，要么在此写法上加上一段回溯。</span></span><br></pre></td></tr></table></figure>



<p>写在前面：在上这门课之前题主没有接触过后面三个算法，因此基本上对来源什么的都不是很懂，大概估计后面三章会在回溯和剪枝出一道大题、概率出一道大题，一共两道大题20分。题主的建议是直接背吧，如果有兴致会在之后出一张本学年的<del>押题卷</del>，模仿样卷的题型罢了。</p>
<h2 id="回溯方法"><a href="#回溯方法" class="headerlink" title="回溯方法"></a>回溯方法</h2><h6 id="使用递归方法生成含-n-个分量的所有排列"><a href="#使用递归方法生成含-n-个分量的所有排列" class="headerlink" title="使用递归方法生成含 n 个分量的所有排列"></a>使用递归方法生成含 n 个分量的所有排列</h6><p>求一个数组的全排列。举个例子方便大家理解：有数组[1,2,3]</p>
<p>全排列为[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iota函数用于对范围赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_Perm</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">X</span><span class="params">(n)</span></span>;</span><br><span class="line"> 	function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; Perm = [&amp;](<span class="type">int</span> t)&#123; </span><br><span class="line">        <span class="keyword">if</span>(t &gt;= n) cout &lt;&lt; X &lt;&lt; endl;</span><br><span class="line"> 		<span class="keyword">else</span></span><br><span class="line"> 			<span class="keyword">for</span>(<span class="type">int</span> i = t; i &lt; n; ++i)&#123; </span><br><span class="line">                <span class="built_in">swap</span>(X[t], X[i]);  <span class="comment">// 交换两个数位置</span></span><br><span class="line"> 				<span class="built_in">Perm</span>(t + <span class="number">1</span>);  <span class="comment">// 交换下一个数（下一层）</span></span><br><span class="line"> 				<span class="built_in">swap</span>(X[t], X[i]);  <span class="comment">// 保持原数组不变</span></span><br><span class="line"> 			&#125;</span><br><span class="line"> 	&#125;;</span><br><span class="line"> 	<span class="built_in">iota</span>(<span class="built_in">begin</span>(X), <span class="built_in">end</span>(X), <span class="number">0</span>);  <span class="comment">// 将X数组置为有序排列（例如X长度为3，则iota后X = [1,2,3]）</span></span><br><span class="line"> 	<span class="built_in">Perm</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="使用递归方法生成-n-个元素的所有子集"><a href="#使用递归方法生成-n-个元素的所有子集" class="headerlink" title="使用递归方法生成 n 个元素的所有子集"></a>使用递归方法生成 n 个元素的所有子集</h6><p>求一个数组的所有子集。举个例子方便大家理解：有数组[1,2,3]</p>
<p>子集为{}, {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_SubSet</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">X</span><span class="params">(n)</span></span>;</span><br><span class="line"> 	function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; SubSet = [&amp;](<span class="type">int</span> t)&#123;</span><br><span class="line">		<span class="keyword">if</span>(t &gt;= n) cout &lt;&lt; X &lt;&lt; endl;</span><br><span class="line"> 		<span class="keyword">else</span>&#123;</span><br><span class="line">			X[t] = <span class="number">1</span>;  <span class="comment">// 对X[t]元素进行判断，=1就是取，=0就是不取</span></span><br><span class="line"> 			<span class="built_in">SubSet</span>(t + <span class="number">1</span>);  <span class="comment">// 为两种状况分别构建队列</span></span><br><span class="line"> 			X[t] = <span class="number">0</span>;</span><br><span class="line"> 			<span class="built_in">SubSet</span>(t + <span class="number">1</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;;</span><br><span class="line"> 	<span class="built_in">SubSet</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="旅行商问题"><a href="#旅行商问题" class="headerlink" title="旅行商问题"></a>旅行商问题</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旅行商问题可以看成是全排列问题，因为一定存在回路（不存在的边给了个INFINITY），所以只需要将所有节点的排列方式找出来，最短的就是最优路径。</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">TSP</span><span class="params">(<span class="type">const</span> Matrix&lt;<span class="type">double</span>&gt; &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n = G.<span class="built_in">rows</span>();</span><br><span class="line"> 	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">X</span><span class="params">(n)</span>, BX</span>;  <span class="comment">// X存到当前节点的路径；BX存最优路径</span></span><br><span class="line"> 	<span class="type">double</span> BC = INFINITY;  <span class="comment">// 预设最大耗费</span></span><br><span class="line"> 	function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">double</span>)&gt; TSP = [&amp;](<span class="type">int</span> t, <span class="type">double</span> C)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t &gt;= n <span class="keyword">and</span> C + <span class="built_in">G</span>(X[n - <span class="number">1</span>], <span class="number">0</span>) &lt; BC)  <span class="comment">// 所有节点都到达且花费更少（答案更优）</span></span><br><span class="line"> 			BC = C + <span class="built_in">G</span>(X[n - <span class="number">1</span>], <span class="number">0</span>), BX = X;</span><br><span class="line"> 		<span class="keyword">else</span> <span class="keyword">if</span>(t &lt; n)</span><br><span class="line"> 			<span class="keyword">for</span>(<span class="type">int</span> i = t; i &lt; n; ++i)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(X[t], X[i]);</span><br><span class="line"> 				<span class="keyword">if</span>(C + <span class="built_in">G</span>(X[t - <span class="number">1</span>], X[t]) &lt; BC)  <span class="comment">// 如果当前路径比最优短，就接着找，已经超了也就没有找下去的必要了</span></span><br><span class="line"> 					<span class="built_in">TSP</span>(t + <span class="number">1</span>, C + <span class="built_in">G</span>(X[t - <span class="number">1</span>], X[t]));</span><br><span class="line"> 				<span class="built_in">swap</span>(X[t], X[i]);</span><br><span class="line"> 			&#125;</span><br><span class="line"> 	&#125;;</span><br><span class="line"> 	<span class="built_in">iota</span>(<span class="built_in">begin</span>(X), <span class="built_in">end</span>(X), <span class="number">0</span>);  <span class="comment">// 初始化</span></span><br><span class="line"> 	<span class="built_in">TSP</span>(<span class="number">1</span>, <span class="number">0</span>);  <span class="comment">// 从第一站开始考虑，当前耗费为0</span></span><br><span class="line"> 	<span class="keyword">return</span> BX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="子集和问题（36输出一个-x2F-不满足-amp-38输出所有）"><a href="#子集和问题（36输出一个-x2F-不满足-amp-38输出所有）" class="headerlink" title="子集和问题（36输出一个&#x2F;不满足 &amp; 38输出所有）"></a>子集和问题（36输出一个&#x2F;不满足 &amp; 38输出所有）</h6><p>简单理解为给定一个数组W，给定一个数字M，求是否W存在子集的子集和等于M。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从题干就知道这一题类似于子集问题</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">SetSum</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;W, <span class="type">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n = W.<span class="built_in">size</span>();</span><br><span class="line"> 	<span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">X</span><span class="params">(n)</span>, Y</span>;</span><br><span class="line"> 	function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; SetSum = [&amp;](<span class="type">int</span> t, <span class="type">int</span> s, <span class="type">int</span> r)&#123; </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> Y.<span class="built_in">empty</span>()) <span class="keyword">return</span>;  <span class="comment">// 不存在，结束</span></span><br><span class="line"> 		<span class="keyword">if</span>(s == M) Y = X, Y.<span class="built_in">resize</span>(t);</span><br><span class="line"> 		<span class="keyword">else</span> <span class="keyword">if</span>(t &lt; n)&#123;</span><br><span class="line">            X[t] = <span class="number">1</span>;</span><br><span class="line"> 			<span class="keyword">if</span>(s + W[t] &lt;= M)  <span class="comment">// 每个元素依然是选或不选两种状态（选了之后仍然小于等于数字M）</span></span><br><span class="line">                <span class="built_in">SetSum</span>(t + <span class="number">1</span>, s + W[t], r - W[t]);</span><br><span class="line"> 			X[t] = <span class="number">0</span>;</span><br><span class="line"> 			<span class="keyword">if</span>(s + (r - W[t]) &gt;= M)  <span class="comment">// 不选的话也要保证可选值大于等于数字M</span></span><br><span class="line">                <span class="built_in">SetSum</span>(t + <span class="number">1</span>, s, r - W[t]);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;;</span><br><span class="line"> 	<span class="type">int</span> s = <span class="number">0</span>, r = <span class="built_in">accumulate</span>(<span class="built_in">begin</span>(W), <span class="built_in">end</span>(W), <span class="number">0</span>);  <span class="comment">// accumulate求和函数，初始为0，累加X数组</span></span><br><span class="line"> 	<span class="built_in">SetSum</span>(<span class="number">0</span>, s, r);</span><br><span class="line"> 	<span class="keyword">return</span> Y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetSum</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;W, <span class="type">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n = W.<span class="built_in">size</span>();</span><br><span class="line"> 	<span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">X</span><span class="params">(n)</span></span>;</span><br><span class="line"> 	function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; SetSum = [&amp;](<span class="type">int</span> t, <span class="type">int</span> s, <span class="type">int</span> r)&#123; </span><br><span class="line">        <span class="keyword">if</span>(s == M) cout &lt;&lt; <span class="built_in">to_string</span>(X, t) &lt;&lt; endl;  <span class="comment">// 存在一种情况直接输出</span></span><br><span class="line"> 		<span class="keyword">else</span> <span class="keyword">if</span>(t &lt; n)&#123;</span><br><span class="line">            X[t] = <span class="number">1</span>;</span><br><span class="line"> 			<span class="keyword">if</span>(s + W[t] &lt;= M) </span><br><span class="line">                <span class="built_in">SetSum</span>(t + <span class="number">1</span>, s + W[t], r - W[t]);</span><br><span class="line"> 			X[t] = <span class="number">0</span>;</span><br><span class="line"> 			<span class="keyword">if</span>(s + (r - W[t]) &gt;= M) </span><br><span class="line">                <span class="built_in">SetSum</span>(t + <span class="number">1</span>, s, r - W[t]);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;;</span><br><span class="line"> 	<span class="type">int</span> s = <span class="number">0</span>, r = <span class="built_in">accumulate</span>(<span class="built_in">begin</span>(W), <span class="built_in">end</span>(W), <span class="number">0</span>);</span><br><span class="line"> 	<span class="built_in">SetSum</span>(<span class="number">0</span>, s, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 显而易见，这两个代码块的区别在于Y，以及方法体中if-else中的if部分。优先记第二种，实在不行你把第二种写上老师都不会扣很多分。</span></span><br></pre></td></tr></table></figure>

<h6 id="最大团问题"><a href="#最大团问题" class="headerlink" title="最大团问题"></a>最大团问题</h6><p>求一个图中连通节点最多的子图</p>
<ul>
<li>扫每一个节点，如果和团中所有节点都连通，可以存；</li>
<li>每个节点都有存和不存两种状态。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Connected</span><span class="params">(<span class="type">const</span> Matrix&lt;<span class="type">bool</span>&gt; &amp;G, <span class="type">const</span> vector&lt;<span class="type">bool</span>&gt; &amp;X, <span class="type">int</span> t)</span>  <span class="comment">// 检查团与节点t的连接性</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; t; ++u)</span><br><span class="line"> 		<span class="keyword">if</span>(X[u] == <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">G</span>(t, u) == <span class="number">0</span>)  <span class="comment">// 如果节点在当前团中但是没有与当前没有连接</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">Clique</span><span class="params">(<span class="type">const</span> Matrix&lt;<span class="type">bool</span>&gt; &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n = G.<span class="built_in">rows</span>(), fn = <span class="number">-1</span>;  <span class="comment">// fn记录最大团的顶点数</span></span><br><span class="line"> 	<span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">X</span><span class="params">(n)</span>, BX</span>;  <span class="comment">// X记录当前团，BX记录最大团</span></span><br><span class="line"> 	function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; Clique = [&amp;](<span class="type">int</span> t, <span class="type">int</span> cn)&#123; </span><br><span class="line">        <span class="keyword">if</span>(t &gt;= n <span class="keyword">and</span> cn &gt; fn) fn = cn, BX = X;</span><br><span class="line"> 		<span class="keyword">else</span> <span class="keyword">if</span>(t &lt; n)&#123; </span><br><span class="line">            X[t] = <span class="number">1</span>;</span><br><span class="line"> 			<span class="keyword">if</span>(<span class="built_in">Connected</span>(G, X, t)) <span class="built_in">Clique</span>(t + <span class="number">1</span>, cn + <span class="number">1</span>);</span><br><span class="line"> 			X[t] = <span class="number">0</span>;</span><br><span class="line"> 			<span class="keyword">if</span>(cn + n - (t + <span class="number">1</span>) &gt; fn) <span class="built_in">Clique</span>(t + <span class="number">1</span>, cn);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;;</span><br><span class="line"> 	<span class="built_in">Clique</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"> 	<span class="keyword">return</span> BX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="着色问题"><a href="#着色问题" class="headerlink" title="着色问题"></a>着色问题</h6><p>这个算是回溯中最难的一个了，依旧是前面的模板，但是写法稍有不同：</p>
<ul>
<li>判断颜色是否和邻边相同，相同就给下一个节点变色，不同则检查下一个节点。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Matrix.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">legal</span><span class="params">(<span class="type">const</span> Matrix&lt;<span class="type">bool</span>&gt; &amp;G, vector&lt;<span class="type">int</span>&gt; &amp;X, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)</span><br><span class="line"> 		<span class="keyword">if</span>(<span class="built_in">G</span>(i, t) == <span class="number">1</span> <span class="keyword">and</span> X[i] == X[t])  <span class="comment">// 连通并且颜色相同返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Chromatic</span><span class="params">(Matrix&lt;<span class="type">bool</span>&gt; &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n = G.<span class="built_in">rows</span>(), fm = n + <span class="number">1</span>; <span class="comment">// 顶点数, fm最优颜色数（其实取n就够了，这里应该是为了让结果更加明显，便于debug）</span></span><br><span class="line"> 	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">X</span><span class="params">(n)</span>, BX</span>; <span class="comment">// 当前方案, 最优方案</span></span><br><span class="line"> 	function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; Chromatic = [&amp;](<span class="type">int</span> t, <span class="type">int</span> m)&#123; <span class="comment">// 搜索解空间树</span></span><br><span class="line"> 		<span class="keyword">if</span>(t &gt;= n <span class="keyword">and</span> m &lt; fm) <span class="comment">// 答案(颜色数更小)</span></span><br><span class="line"> 			BX = X, fm = m;</span><br><span class="line"> 		<span class="keyword">else</span> <span class="keyword">if</span>(t &lt; n)</span><br><span class="line"> 			<span class="keyword">for</span>(X[t] = <span class="number">1</span>; X[t] &lt;= m; ++X[t])&#123; </span><br><span class="line">                <span class="keyword">auto</span> cm = <span class="built_in">max</span>(X[t] + <span class="number">1</span>, m);  <span class="comment">// 新的颜色数(可能需要增加)</span></span><br><span class="line"> 				<span class="keyword">if</span>(<span class="built_in">legal</span>(G, X, t) <span class="keyword">and</span> cm &lt; fm)  <span class="comment">// X[t]可用且颜色数可能更小</span></span><br><span class="line"> 					<span class="built_in">Chromatic</span>(t + <span class="number">1</span>, cm);  <span class="comment">// 下一顶点</span></span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;;</span><br><span class="line"> 	<span class="built_in">Chromatic</span>(<span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 从顶点0开始, 初始颜色数为1, 上限为n</span></span><br><span class="line"> 	<span class="keyword">return</span> BX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="分枝限界方法"><a href="#分枝限界方法" class="headerlink" title="分枝限界方法"></a>分枝限界方法</h2><p>通俗来说就是回溯算法中的剪枝操作，上面的回溯算法用的是深度优先遍历，那么下文的分枝限界算法就是用的宽度优先遍历，个人结论就是和图遍历一样，回溯用递归能解决，剪枝就需要用到队列queue了，如果还不是很懂queue的建议取找个文档简单阅读一下queue的基本操作。</p>
<h6 id="使用分枝限界方法生成含-n-个分量的所有排列"><a href="#使用分枝限界方法生成含-n-个分量的所有排列" class="headerlink" title="使用分枝限界方法生成含 n 个分量的所有排列"></a>使用分枝限界方法生成含 n 个分量的所有排列</h6><ul>
<li>首先我们明确一点就是回溯的思想是递归，而分枝限界的思想是递推，也就是说用通项公式来解决问题。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PermNode</span></span><br><span class="line">&#123; </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; X;</span><br><span class="line"> 	<span class="type">int</span> t;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Perm</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    queue&lt;PermNode&gt; Q;</span><br><span class="line"> 	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">X</span><span class="params">(n)</span></span>;  <span class="comment">// X用来存数组中的元素排序，t用来存数组中的元素个数</span></span><br><span class="line"> 	<span class="built_in">iota</span>(<span class="built_in">begin</span>(X), <span class="built_in">end</span>(X), <span class="number">0</span>);</span><br><span class="line"> 	Q.<span class="built_in">push</span>(&#123;X, <span class="number">0</span>&#125;);</span><br><span class="line"> 	<span class="keyword">while</span>(<span class="keyword">not</span> Q.<span class="built_in">empty</span>())&#123; </span><br><span class="line">        <span class="keyword">auto</span> [X, t] = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line"> 		<span class="keyword">if</span>(t &gt;= n) cout &lt;&lt; X &lt;&lt; endl;</span><br><span class="line"> 		<span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = t; i &lt; n; ++i)</span><br><span class="line"> 				<span class="built_in">swap</span>(X[t], X[i]), Q.<span class="built_in">push</span>(&#123;X, t + <span class="number">1</span>&#125;);  <span class="comment">// 将所有的邻边全部入队</span></span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="使用分枝限界方法生成-n-个元素的所有子集"><a href="#使用分枝限界方法生成-n-个元素的所有子集" class="headerlink" title="使用分枝限界方法生成 n 个元素的所有子集"></a>使用分枝限界方法生成 n 个元素的所有子集</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SetNode</span></span><br><span class="line">&#123; </span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; X;</span><br><span class="line"> 	<span class="type">int</span> t;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SubSet</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    queue&lt;SetNode&gt; Q;</span><br><span class="line"> 	<span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">X</span><span class="params">(n)</span></span>;</span><br><span class="line"> 	Q.<span class="built_in">push</span>(&#123;X, <span class="number">0</span>&#125;);</span><br><span class="line"> 	<span class="keyword">while</span>(<span class="keyword">not</span> Q.<span class="built_in">empty</span>())&#123; </span><br><span class="line">        <span class="keyword">auto</span>[X, t] = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line"> 		<span class="keyword">if</span>(t &gt;= n) cout &lt;&lt; X &lt;&lt; endl;</span><br><span class="line"> 		<span class="keyword">else</span>&#123; </span><br><span class="line">            X[t] = <span class="number">1</span>, Q.<span class="built_in">push</span>(&#123;X, t + <span class="number">1</span>&#125;);  <span class="comment">// 为选了X[t]的元素构建一条队列</span></span><br><span class="line"> 			X[t] = <span class="number">0</span>, Q.<span class="built_in">push</span>(&#123;X, t + <span class="number">1</span>&#125;);  <span class="comment">// 为不选X[t]的元素构建一条队列</span></span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了以上基础，以下三个就是大同小异了，这里不做过多解释。写不出来的话用前两题的思想套入问题，写写白话吧，毕竟这里不推荐大家背书。。。</p>
<h6 id="旅行商问题-1"><a href="#旅行商问题-1" class="headerlink" title="旅行商问题"></a>旅行商问题</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TSPNode</span></span><br><span class="line">&#123; </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; X;</span><br><span class="line"> 	<span class="type">int</span> t;</span><br><span class="line"> 	<span class="type">double</span> C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> TSPNode &amp;X, <span class="type">const</span> TSPNode &amp;Y)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> X.C &lt; Y.C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">TSP</span><span class="params">(<span class="type">const</span> Matrix&lt;<span class="type">double</span>&gt; &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    minheap&lt;TSPNode&gt; H;</span><br><span class="line"> 	<span class="type">int</span> n = G.<span class="built_in">rows</span>();</span><br><span class="line"> 	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">X</span><span class="params">(n)</span>, BX</span>;</span><br><span class="line"> 	<span class="built_in">iota</span>(<span class="built_in">begin</span>(X), <span class="built_in">end</span>(X), <span class="number">0</span>);</span><br><span class="line"> 	<span class="type">double</span> C = <span class="number">0</span>, BC = INFINITY;</span><br><span class="line"> 	H.<span class="built_in">push</span>(&#123;X, <span class="number">1</span>, C&#125;);</span><br><span class="line"> 	<span class="keyword">while</span>(<span class="keyword">not</span> H.<span class="built_in">empty</span>())&#123; </span><br><span class="line">        <span class="keyword">auto</span> [X, t, C] = H.<span class="built_in">top</span>(); H.<span class="built_in">pop</span>();</span><br><span class="line"> 		<span class="keyword">if</span>(t &gt;= n <span class="keyword">and</span> C + <span class="built_in">G</span>(X[n - <span class="number">1</span>], <span class="number">0</span>) &lt; BC)</span><br><span class="line"> 			BC = C + <span class="built_in">G</span>(X[n - <span class="number">1</span>], <span class="number">0</span>), BX = X;</span><br><span class="line"> 		<span class="keyword">else</span> <span class="keyword">if</span>(t &lt; n)</span><br><span class="line"> 			<span class="keyword">for</span>(<span class="type">int</span> i = t; i &lt; n; ++i)&#123; </span><br><span class="line">                <span class="built_in">swap</span>(X[t], X[i]);</span><br><span class="line"> 				<span class="keyword">if</span>(C + <span class="built_in">G</span>(X[t - <span class="number">1</span>], X[t]) &lt; BC)</span><br><span class="line"> 					H.<span class="built_in">push</span>(&#123;X, t + <span class="number">1</span>, C + <span class="built_in">G</span>(X[t - <span class="number">1</span>], X[t])&#125;);</span><br><span class="line"> 			&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> BX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="最大团问题-1"><a href="#最大团问题-1" class="headerlink" title="最大团问题"></a>最大团问题</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Connected</span><span class="params">(<span class="type">const</span> Matrix&lt;<span class="type">bool</span>&gt; &amp;G, <span class="type">const</span> vector&lt;<span class="type">bool</span>&gt; &amp;X, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; t; ++u)</span><br><span class="line"> 		<span class="keyword">if</span>(X[u] == <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">G</span>(t, u) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CliqueNode</span></span><br><span class="line">&#123; </span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; X;</span><br><span class="line"> 	<span class="type">int</span> t, cn;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> CliqueNode &amp;X, <span class="type">const</span> CliqueNode &amp;Y)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> X.cn &lt; Y.cn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt; <span class="type">bool</span>&gt; <span class="title">Clique</span><span class="params">(<span class="type">const</span> Matrix&lt;<span class="type">bool</span>&gt; &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    maxheap&lt;CliqueNode&gt; H;</span><br><span class="line"> 	<span class="type">int</span> n = G.<span class="built_in">rows</span>();</span><br><span class="line"> 	<span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">X</span><span class="params">(n)</span>, BX</span>;</span><br><span class="line"> 	<span class="type">int</span> cn = <span class="number">0</span>, fn = <span class="number">0</span>;</span><br><span class="line"> 	H.<span class="built_in">push</span>(&#123;X, <span class="number">0</span>, cn&#125;);</span><br><span class="line"> 	<span class="keyword">while</span>(<span class="keyword">not</span> H.<span class="built_in">empty</span>())&#123; </span><br><span class="line">        <span class="keyword">auto</span> [X, t, cn] = H.<span class="built_in">top</span>(); H.<span class="built_in">pop</span>();</span><br><span class="line"> 		<span class="keyword">if</span>(t &gt;= n <span class="keyword">and</span> cn &gt; fn) fn = cn, BX = X;</span><br><span class="line"> 		<span class="keyword">else</span> <span class="keyword">if</span>(t &lt; n)&#123; </span><br><span class="line">            X[t] = <span class="number">1</span>;</span><br><span class="line"> 			<span class="keyword">if</span>(<span class="built_in">Connected</span>(G, X, t)) H.<span class="built_in">push</span>(&#123;X, t + <span class="number">1</span>, cn + <span class="number">1</span>&#125;);</span><br><span class="line"> 			X[t] = <span class="number">0</span>;</span><br><span class="line"> 			<span class="keyword">if</span>(cn + n - (t + <span class="number">1</span>) &gt; fn) H.<span class="built_in">push</span>(&#123;X, t + <span class="number">1</span>, cn&#125;);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> BX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="子集和问题（44输出所有-amp-45输出一个-x2F-不满足）"><a href="#子集和问题（44输出所有-amp-45输出一个-x2F-不满足）" class="headerlink" title="子集和问题（44输出所有 &amp; 45输出一个&#x2F;不满足）"></a>子集和问题（44输出所有 &amp; 45输出一个&#x2F;不满足）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SetSumNode</span></span><br><span class="line">&#123; </span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; X;</span><br><span class="line"> 	<span class="type">int</span> t, s, r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetSum</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;W, <span class="type">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    queue&lt;SetSumNode&gt; Q;</span><br><span class="line"> 	<span class="type">int</span> n = W.<span class="built_in">size</span>();</span><br><span class="line"> 	<span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">X</span><span class="params">(n)</span></span>;</span><br><span class="line"> 	<span class="type">int</span> s = <span class="number">0</span>, r = <span class="built_in">accumulate</span>(<span class="built_in">begin</span>(W), <span class="built_in">end</span>(W), <span class="number">0</span>);</span><br><span class="line"> 	Q.<span class="built_in">push</span>(&#123;X, <span class="number">0</span>, s, r&#125;);</span><br><span class="line"> 	<span class="keyword">while</span>(<span class="keyword">not</span> Q.<span class="built_in">empty</span>())&#123; </span><br><span class="line">        <span class="keyword">auto</span> [X, t, s, r] = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line"> 		<span class="keyword">if</span>(s == M) cout &lt;&lt; <span class="built_in">to_string</span>(X, t) &lt;&lt; endl;</span><br><span class="line"> 		<span class="keyword">else</span> <span class="keyword">if</span>(t &lt; n)&#123; </span><br><span class="line">            X[t] = <span class="number">1</span>;</span><br><span class="line"> 			<span class="keyword">if</span>(s + W[t] &lt;= M)</span><br><span class="line"> 				Q.<span class="built_in">push</span>(&#123;X, t + <span class="number">1</span>, s + W[t], r - W[t]&#125;);</span><br><span class="line"> 			X[t] = <span class="number">0</span>;</span><br><span class="line"> 			<span class="keyword">if</span>(s + (r - W[t]) &gt;= M)</span><br><span class="line"> 				Q.<span class="built_in">push</span>(&#123;X, t + <span class="number">1</span>, s, r - W[t]&#125;);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SetSumNode</span></span><br><span class="line">&#123; </span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; X;</span><br><span class="line"> 	<span class="type">int</span> t, s, r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">SetSum</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;W, <span class="type">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    queue&lt;SetSumNode&gt; Q;</span><br><span class="line"> 	<span class="type">int</span> n = W.<span class="built_in">size</span>();</span><br><span class="line"> 	<span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">X</span><span class="params">(n)</span>, Y</span>;</span><br><span class="line"> 	<span class="type">int</span> s = <span class="number">0</span>, r = <span class="built_in">accumulate</span>(<span class="built_in">begin</span>(W), <span class="built_in">end</span>(W), <span class="number">0</span>);</span><br><span class="line"> 	Q.<span class="built_in">push</span>(&#123;X, <span class="number">0</span>, s, r&#125;);</span><br><span class="line"> 	<span class="keyword">while</span>(<span class="keyword">not</span> Q.<span class="built_in">empty</span>())&#123; </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> Y.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line"> 			<span class="keyword">auto</span> [X, t, s, r] = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line"> 		<span class="keyword">if</span>(s == M) Y = X, Y.<span class="built_in">resize</span>(t);</span><br><span class="line"> 		<span class="keyword">else</span> <span class="keyword">if</span>(t &lt; n)&#123; </span><br><span class="line">            X[t] = <span class="number">1</span>;</span><br><span class="line"> 			<span class="keyword">if</span>(s + W[t] &lt;= M) Q.<span class="built_in">push</span>(&#123;X, t + <span class="number">1</span>, s + W[t], r - W[t]&#125;);</span><br><span class="line"> 			X[t] = <span class="number">0</span>;</span><br><span class="line"> 			<span class="keyword">if</span>(s + (r - W[t]) &gt;= M) Q.<span class="built_in">push</span>(&#123;X, t + <span class="number">1</span>, s, r - W[t]&#125;);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> Y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="概率方法"><a href="#概率方法" class="headerlink" title="概率方法"></a>概率方法</h2><h6 id="随机方法改写快速排序程序"><a href="#随机方法改写快速排序程序" class="headerlink" title="随机方法改写快速排序程序"></a>随机方法改写快速排序程序</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(T X[], <span class="type">int</span> low, <span class="type">int</span> up)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> key = <span class="built_in">rand</span>() % (up - low) + low, p = low;  <span class="comment">// key值随机生成，其他和快速排序一模一样</span></span><br><span class="line"> 	<span class="built_in">swap</span>(X[key], X[up - <span class="number">1</span>]), key = up - <span class="number">1</span>;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = low; i &lt; key; ++i)</span><br><span class="line"> 		<span class="keyword">if</span>(X[i] &lt; X[key]) </span><br><span class="line">            <span class="built_in">swap</span>(X[i], X[p]), ++p;</span><br><span class="line"> 	<span class="built_in">swap</span>(X[key], X[p]);</span><br><span class="line"> 	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(T X[], <span class="type">int</span> low, <span class="type">int</span> up)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(up - low &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> 	<span class="type">int</span> m = <span class="built_in">Partition</span>(X, low, up);</span><br><span class="line"> 	<span class="built_in">QuickSort</span>(X, low, m);</span><br><span class="line"> 	<span class="built_in">QuickSort</span>(X, m + <span class="number">1</span>, up);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="随机方法改写基于划分的选择程序"><a href="#随机方法改写基于划分的选择程序" class="headerlink" title="随机方法改写基于划分的选择程序"></a>随机方法改写基于划分的选择程序</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(T X[], <span class="type">int</span> low, <span class="type">int</span> up)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> key = <span class="built_in">rand</span>() % (up - low) + low, p = low;  <span class="comment">// key值随机生成，其他和选择排序一模一样</span></span><br><span class="line"> 	<span class="built_in">swap</span>(X[key], X[up - <span class="number">1</span>]), key = up - <span class="number">1</span>;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = low; i &lt; key; ++i)</span><br><span class="line"> 		<span class="keyword">if</span>(X[i] &lt; X[key]) </span><br><span class="line">            <span class="built_in">swap</span>(X[i], X[p]), ++p;</span><br><span class="line"> 	<span class="built_in">swap</span>(X[key], X[p]);</span><br><span class="line"> 	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T &amp;<span class="title">Select</span><span class="params">(T X[], <span class="type">int</span> n, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, up = n;</span><br><span class="line"> 	<span class="keyword">for</span>(;;)&#123; </span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">Partition</span>(X, low, up);</span><br><span class="line"> 		<span class="keyword">if</span>(k == m) <span class="keyword">return</span> X[m];</span><br><span class="line"> 		<span class="keyword">else</span> <span class="keyword">if</span>(k &lt; m) up = m;</span><br><span class="line"> 		<span class="keyword">else</span> low = m + <span class="number">1</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="随机洗牌算法"><a href="#随机洗牌算法" class="headerlink" title="随机洗牌算法"></a>随机洗牌算法</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shuffle</span><span class="params">(T X[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">for</span>(--n; n &gt; <span class="number">0</span>; --n)</span><br><span class="line"> 		<span class="built_in">swap</span>(X[n], X[<span class="built_in">rand</span>() % n]);  <span class="comment">// 随机交换元素，将数组完全打乱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="插入说明："><a href="#插入说明：" class="headerlink" title="插入说明："></a>插入说明：</h6><p>虽然题库里都是拉斯维加斯算法的求解过程，但是生活处处充满惊喜，谁也不知道他会不会出一个算法以外的题或者其他算法的题给你，因此在这里题主详细但又简洁的介绍下三种概率方法（蒙特卡洛算法、拉斯维加斯算法、舍伍德算法）</p>
<ul>
<li>拉斯维加斯算法：不会得到错误解，但是有可能找不到解。（在下面的题目中形容得比较简单，对于需要排序的问题就是在开始将数组随机打乱；而对于需要求子集的问题，就是在判断一个元素选还是不选时引入随机数，就这么看来，概率算法其实是试卷的送分题【基础题型加一句随机数描述】）</li>
<li>蒙特卡洛算法：用于求问题的准确解，但是这个解不能保证是正确的。</li>
<li>舍伍德算法：总能得到问题的一个解，且得到的解一定是正确的。（通过确定算法引入随机数，消除&#x2F;减少好坏实例之间的区别）</li>
</ul>
<p>了解了这三个随机算法的区别后，考试的时候怎么办？如果真的出现了其他的概率算法怎么写？题主的建议是全按照拉斯维加斯算法的过程写，因为都是在基础题型上加上随机判断，三个算法的区别就是随机算法安插的位置和次数（1~2次）不同，所以没必要纠结之间的差别，拿个大头就好！</p>
<h6 id="拉斯维加斯算法求解旅行商问题（是否存在耗费不超过t的旅行）"><a href="#拉斯维加斯算法求解旅行商问题（是否存在耗费不超过t的旅行）" class="headerlink" title="拉斯维加斯算法求解旅行商问题（是否存在耗费不超过t的旅行）"></a>拉斯维加斯算法求解旅行商问题（是否存在耗费不超过t的旅行）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TSP</span><span class="params">(<span class="type">const</span> Matrix&lt;<span class="type">double</span>&gt; &amp;G, <span class="type">double</span> t, vector&lt;<span class="type">int</span>&gt; &amp;X)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n = G.<span class="built_in">rows</span>();</span><br><span class="line"> 	<span class="built_in">iota</span>(<span class="built_in">begin</span>(X), <span class="built_in">end</span>(X), <span class="number">0</span>);</span><br><span class="line"> 	<span class="built_in">random_shuffle</span>(<span class="built_in">begin</span>(X), <span class="built_in">end</span>(X));  <span class="comment">// 对一个数组随机排列</span></span><br><span class="line"> 	<span class="type">double</span> s = <span class="number">0</span>;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++k)&#123; </span><br><span class="line">        s += <span class="built_in">G</span>(X[k % n], X[(k + <span class="number">1</span>) % n]);</span><br><span class="line"> 		<span class="keyword">if</span>(s &gt; t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="拉斯维加斯算法求解0-x2F-1背包问题（是否存在效益和不少于t的装包方式）"><a href="#拉斯维加斯算法求解0-x2F-1背包问题（是否存在效益和不少于t的装包方式）" class="headerlink" title="拉斯维加斯算法求解0&#x2F;1背包问题（是否存在效益和不少于t的装包方式）"></a>拉斯维加斯算法求解0&#x2F;1背包问题（是否存在效益和不少于t的装包方式）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Knap</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">double</span>&gt; &amp;V, <span class="type">const</span> vector&lt;<span class="type">double</span>&gt; &amp;W,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">double</span> c, <span class="type">double</span> t, vector&lt;<span class="type">bool</span>&gt; &amp;X)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">min</span>(V.<span class="built_in">size</span>(), W.<span class="built_in">size</span>());</span><br><span class="line"> 	<span class="type">double</span> fv = <span class="number">0</span>, fw = <span class="number">0</span>;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123; </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">rand</span>() % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line"> 			X[i] = <span class="number">1</span>, fv += V[i], fw += W[i];</span><br><span class="line"> 		<span class="keyword">else</span></span><br><span class="line"> 			X[i] = <span class="number">0</span>;</span><br><span class="line"> 		<span class="keyword">if</span>(fw &gt; c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> fv &gt;= t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="拉斯维加斯算法求解Hamilton回路问题（是否有Hamilton回路）"><a href="#拉斯维加斯算法求解Hamilton回路问题（是否有Hamilton回路）" class="headerlink" title="拉斯维加斯算法求解Hamilton回路问题（是否有Hamilton回路）"></a>拉斯维加斯算法求解Hamilton回路问题（是否有Hamilton回路）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Hamilton</span><span class="params">(<span class="type">const</span> Matrix&lt;<span class="type">bool</span>&gt; &amp;G, vector&lt;<span class="type">int</span>&gt; &amp;X)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n = G.<span class="built_in">rows</span>();</span><br><span class="line"> 	<span class="built_in">iota</span>(<span class="built_in">begin</span>(X), <span class="built_in">end</span>(X), <span class="number">0</span>);</span><br><span class="line"> 	<span class="built_in">random_shuffle</span>(<span class="built_in">begin</span>(X), <span class="built_in">end</span>(X));</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++k)&#123; </span><br><span class="line">        <span class="type">int</span> i = X[k], j = X[(k + <span class="number">1</span>) % n];</span><br><span class="line"> 		<span class="keyword">if</span>(<span class="built_in">G</span>(i, j) != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="拉斯维加斯算法求解子集和问题（是否存在和为t的子集）"><a href="#拉斯维加斯算法求解子集和问题（是否存在和为t的子集）" class="headerlink" title="拉斯维加斯算法求解子集和问题（是否存在和为t的子集）"></a>拉斯维加斯算法求解子集和问题（是否存在和为t的子集）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SetSum</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;W, <span class="type">int</span> t, vector&lt;<span class="type">bool</span>&gt; &amp;X)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; W.<span class="built_in">size</span>(); ++i)&#123; </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">rand</span>() % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line"> 			X[i] = <span class="number">1</span>, s += W[i];</span><br><span class="line"> 		<span class="keyword">else</span></span><br><span class="line"> 			X[i] = <span class="number">0</span>;</span><br><span class="line"> 		<span class="keyword">if</span>(s &gt; t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> s == t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="拉斯维加斯算法求解团问题（是否存在顶点数不小于k的团）"><a href="#拉斯维加斯算法求解团问题（是否存在顶点数不小于k的团）" class="headerlink" title="拉斯维加斯算法求解团问题（是否存在顶点数不小于k的团）"></a>拉斯维加斯算法求解团问题（是否存在顶点数不小于k的团）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Clique</span><span class="params">(<span class="type">const</span> Matrix&lt;<span class="type">bool</span>&gt; &amp;G, <span class="type">int</span> k, vector&lt;<span class="type">bool</span>&gt; &amp;X)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> n = G.<span class="built_in">rows</span>(), m = <span class="number">0</span>;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"> 		<span class="keyword">if</span>(<span class="built_in">rand</span>() % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line"> 			X[i] = <span class="number">1</span>, ++m;</span><br><span class="line"> 		<span class="keyword">else</span></span><br><span class="line"> 			X[i] = <span class="number">0</span>;</span><br><span class="line"> 		<span class="keyword">if</span>(m &lt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"> 		<span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line"> 			<span class="keyword">if</span>(X[i] == <span class="number">1</span> <span class="keyword">and</span> X[j] == <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">G</span>(i, j) != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，这门课这本书的所有内容（其实就是简单讲解了下题库）都已经完结了！恭喜恭喜，如果你是从头到尾认真一路复习下来的，那么毫无疑问，你八成已经忘得差不多了QWQ（因为题主两天半写到这发现真要随机抽一道给我确实不一定会写）。但是不用担心，基本上认真看到这的对于各问题的基本思路都已经成型，大家大可按照自己喜欢的、方便的语言去完成算法。两章回溯由于题主也是第一次接触，并且老师上课节奏较快（咱也不是认真听课的人），所以采用的是强记的方式。这两天题主会根据样卷出一份考前押题卷，一个是加强自己的手写能力，二个题库的题过了一遍，发现有些题太简单了，而有些题太难了，可以很大程度的缩小背记范围。那么，这个文档到此就告一段落了，之后应该是上传到GitHub上供未来的学弟学妹参考了（毕竟考前两天才完成）。</p>
<p>加油加油！                                                                                                                                                            ——By Alexie-Z-Yevich 2022.5.8</p>
<hr>
<p>算是版本2.0吧，因为之前对于回溯和分枝限界不是很了解，所以连带着概率也没怎么给大家写，今天把之前埋的坑都填上了，还是好难啊，押题卷昨天就出完了，大家感兴趣还是可以看一下滴。（其实今天又过了一遍题，如果真在题库里抽的话，那么其实没啥好押题的，真是谁也说不清呢）                                                                                                                                             ——By Alexie-Z-Yevich 2022.5.9</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.fenrisx.icu">Alexie-Z-Yevich</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.fenrisx.icu/2022/06/12/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">https://www.fenrisx.icu/2022/06/12/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.fenrisx.icu" target="_blank">New Try && New Life</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="/images/head.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/23/%E8%85%BE%E8%AE%AF%E9%9F%B3%E4%B9%90%E6%B5%B7%E7%AC%94%E5%A4%8D%E7%9B%98/" title="22腾讯音乐暑期实习海笔复盘"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-23</div><div class="title">22腾讯音乐暑期实习海笔复盘</div></div></a></div><div><a href="/2022/07/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/" title="人工智能导论"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-01</div><div class="title">人工智能导论</div></div></a></div><div><a href="/2022/07/01/%E8%AE%A1%E7%AE%97%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/" title="计算智能导论"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-01</div><div class="title">计算智能导论</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Alexie-Z-Yevich</div><div class="author-info__description">hello</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">50</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Alexie-Z-Yevich"><i></i><span>前往我的Github...</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Alexie-Z-Yevich" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1213791406@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><center>主域名：<br><a href="https://www.fenrisx.icu"><b><font color="#5ea6e5">fenrisx.icu</font></b></a><br>其他项目：<br><a target="_blank" rel="noopener" href="http://www.fenrisx.top"><b><font color="#5ea6e5">fenrisx.top</font></b></a><br>📬：<b><font color="#a591e0">1213791406@qq.com</font></b></a></center></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-text">前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#vector"><span class="toc-text">vector</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#set"><span class="toc-text">set</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#queue"><span class="toc-text">queue</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#functional"><span class="toc-text">functional</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Matrix"><span class="toc-text">Matrix</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E7%AC%A6%E5%8F%B7"><span class="toc-text">渐进符号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E7%AC%A6%E5%8F%B7O%EF%BC%88%E4%B8%8A%E7%95%8C%EF%BC%89%E3%80%90%E8%80%83%E7%82%B9%E3%80%91"><span class="toc-text">渐进符号O（上界）【考点】</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81%E7%AC%A6%E5%8F%B7O%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1、符号O的定义</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E3%80%90%E5%A4%A7O%E6%AF%94%E7%8E%87%E5%AE%9A%E7%90%86%E3%80%91"><span class="toc-text">2、【大O比率定理】</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E3%80%81%E3%80%90%E5%B8%B8%E7%94%A8%E4%B8%8A%E7%95%8C%E5%85%B3%E7%B3%BB%E5%AE%9A%E7%90%86%E3%80%91-%E7%94%B1%E5%A4%A7O%E6%AF%94%E7%8E%87%E5%AE%9A%E7%90%86%E8%AF%81%E6%98%8E"><span class="toc-text">3、【常用上界关系定理】 (由大O比率定理证明)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E7%AC%A6%E5%8F%B7%CE%A9%EF%BC%88%E4%B8%8B%E7%95%8C%EF%BC%89"><span class="toc-text">渐进符号Ω（下界）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81%E7%AC%A6%E5%8F%B7%CE%A9%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1、符号Ω的定义</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E3%80%90%E5%A4%A7%CE%A9%E6%AF%94%E7%8E%87%E5%AE%9A%E7%90%86%E3%80%91"><span class="toc-text">2、【大Ω比率定理】</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E7%AC%A6%E5%8F%B7%CE%98%EF%BC%88%E5%8F%8C%E7%95%8C%EF%BC%89"><span class="toc-text">渐进符号Θ（双界）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81%E7%AC%A6%E5%8F%B7%CE%98%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1、符号Θ的定义</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E3%80%90%E5%A4%A7%CE%98%E6%AF%94%E7%8E%87%E5%AE%9A%E7%90%86%E3%80%91"><span class="toc-text">2、【大Θ比率定理】</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8C%96Master%E5%AE%9A%E7%90%86%E3%80%90%E8%80%83%E7%82%B9%E3%80%91"><span class="toc-text">简化Master定理【考点】</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81%E5%AE%9A%E7%90%86%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-text">1、定理适用范围</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E7%AE%80%E5%8C%96Master%E5%AE%9A%E7%90%86"><span class="toc-text">2、简化Master定理</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88%E5%8D%87%E5%BA%8F%E6%8E%92%E5%88%97%EF%BC%89"><span class="toc-text">选择排序（升序排列）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88%E5%8D%87%E5%BA%8F%E6%8E%92%E5%88%97%E4%B8%94%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%89"><span class="toc-text">插入排序（升序排列且不含重复元素）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88%E5%8D%87%E5%BA%8F%E6%8E%92%E5%88%97%EF%BC%89"><span class="toc-text">插入排序（升序排列）</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="toc-text">图遍历方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E6%A0%91%E7%9A%84%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">一般树的先序遍历</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的层次遍历</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95"><span class="toc-text">连通图的宽度优先搜索算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95"><span class="toc-text">连通图的深度优先算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88%E6%94%B9%EF%BC%89%E8%AE%A1%E7%AE%97%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-text">二叉树的深度优先搜索（改）计算每个节点的深度</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88%E6%94%B9%EF%BC%89%E8%AE%A1%E7%AE%97%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="toc-text">一般树的深度优先搜索（改）计算每个节点的层次</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%EF%BC%88%E6%94%B9%EF%BC%89%E8%AE%A1%E7%AE%97%E6%AF%8F%E4%B8%AA%E9%A1%B6%E7%82%B9%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="toc-text">连通图的深度优先遍历算法（改）计算每个顶点的层次</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%EF%BC%88%E6%94%B9%EF%BC%89%E8%BE%93%E5%87%BA%E5%9B%BE%E7%9A%84%E6%AF%8F%E4%B8%AA%E8%BF%9E%E9%80%9A%E5%88%86%E6%94%AF"><span class="toc-text">图的宽度优先遍历算法（改）输出图的每个连通分支</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E6%96%B9%E6%B3%95"><span class="toc-text">分治方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2%EF%BC%88%E5%8D%87%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%89"><span class="toc-text">折半搜索（升序数组）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="toc-text">线性时间选择算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%89"><span class="toc-text">合并数组（不含重复元素）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A5%87%E5%81%B6%E5%88%92%E5%88%86"><span class="toc-text">奇偶划分</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-text">贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A3%85%E8%BD%BD%E9%97%AE%E9%A2%98"><span class="toc-text">装载问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">背包问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98"><span class="toc-text">活动安排问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91Prim%E7%AE%97%E6%B3%95"><span class="toc-text">最小生成树Prim算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91Kruskal%E7%AE%97%E6%B3%95"><span class="toc-text">最小生成树Kruskal算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%9A%E6%9C%BA%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="toc-text">多机调度问题</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95"><span class="toc-text">动态规划算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98%E6%9C%80%E4%BC%98%E6%AC%A1%E5%BA%8F"><span class="toc-text">矩阵连乘最优次序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E9%A1%B6%E7%82%B9%E9%97%B4%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6"><span class="toc-text">任意顶点间最短路径长度</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%9A%E6%AE%B5%E5%9B%BE"><span class="toc-text">多段图</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2"><span class="toc-text">两个字符串的最长公共子串</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#0-x2F-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">0&#x2F;1背包问题</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%96%B9%E6%B3%95"><span class="toc-text">回溯方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95%E7%94%9F%E6%88%90%E5%90%AB-n-%E4%B8%AA%E5%88%86%E9%87%8F%E7%9A%84%E6%89%80%E6%9C%89%E6%8E%92%E5%88%97"><span class="toc-text">使用递归方法生成含 n 个分量的所有排列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95%E7%94%9F%E6%88%90-n-%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86"><span class="toc-text">使用递归方法生成 n 个元素的所有子集</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98"><span class="toc-text">旅行商问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%90%E9%9B%86%E5%92%8C%E9%97%AE%E9%A2%98%EF%BC%8836%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%AA-x2F-%E4%B8%8D%E6%BB%A1%E8%B6%B3-amp-38%E8%BE%93%E5%87%BA%E6%89%80%E6%9C%89%EF%BC%89"><span class="toc-text">子集和问题（36输出一个&#x2F;不满足 &amp; 38输出所有）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%9B%A2%E9%97%AE%E9%A2%98"><span class="toc-text">最大团问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98"><span class="toc-text">着色问题</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%9D%E9%99%90%E7%95%8C%E6%96%B9%E6%B3%95"><span class="toc-text">分枝限界方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%9D%E9%99%90%E7%95%8C%E6%96%B9%E6%B3%95%E7%94%9F%E6%88%90%E5%90%AB-n-%E4%B8%AA%E5%88%86%E9%87%8F%E7%9A%84%E6%89%80%E6%9C%89%E6%8E%92%E5%88%97"><span class="toc-text">使用分枝限界方法生成含 n 个分量的所有排列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%9D%E9%99%90%E7%95%8C%E6%96%B9%E6%B3%95%E7%94%9F%E6%88%90-n-%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86"><span class="toc-text">使用分枝限界方法生成 n 个元素的所有子集</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98-1"><span class="toc-text">旅行商问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%9B%A2%E9%97%AE%E9%A2%98-1"><span class="toc-text">最大团问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%90%E9%9B%86%E5%92%8C%E9%97%AE%E9%A2%98%EF%BC%8844%E8%BE%93%E5%87%BA%E6%89%80%E6%9C%89-amp-45%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%AA-x2F-%E4%B8%8D%E6%BB%A1%E8%B6%B3%EF%BC%89"><span class="toc-text">子集和问题（44输出所有 &amp; 45输出一个&#x2F;不满足）</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E7%8E%87%E6%96%B9%E6%B3%95"><span class="toc-text">概率方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%96%B9%E6%B3%95%E6%94%B9%E5%86%99%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%A8%8B%E5%BA%8F"><span class="toc-text">随机方法改写快速排序程序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%96%B9%E6%B3%95%E6%94%B9%E5%86%99%E5%9F%BA%E4%BA%8E%E5%88%92%E5%88%86%E7%9A%84%E9%80%89%E6%8B%A9%E7%A8%8B%E5%BA%8F"><span class="toc-text">随机方法改写基于划分的选择程序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95"><span class="toc-text">随机洗牌算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">插入说明：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8B%89%E6%96%AF%E7%BB%B4%E5%8A%A0%E6%96%AF%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98%EF%BC%88%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%80%97%E8%B4%B9%E4%B8%8D%E8%B6%85%E8%BF%87t%E7%9A%84%E6%97%85%E8%A1%8C%EF%BC%89"><span class="toc-text">拉斯维加斯算法求解旅行商问题（是否存在耗费不超过t的旅行）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8B%89%E6%96%AF%E7%BB%B4%E5%8A%A0%E6%96%AF%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A30-x2F-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%95%88%E7%9B%8A%E5%92%8C%E4%B8%8D%E5%B0%91%E4%BA%8Et%E7%9A%84%E8%A3%85%E5%8C%85%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-text">拉斯维加斯算法求解0&#x2F;1背包问题（是否存在效益和不少于t的装包方式）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8B%89%E6%96%AF%E7%BB%B4%E5%8A%A0%E6%96%AF%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3Hamilton%E5%9B%9E%E8%B7%AF%E9%97%AE%E9%A2%98%EF%BC%88%E6%98%AF%E5%90%A6%E6%9C%89Hamilton%E5%9B%9E%E8%B7%AF%EF%BC%89"><span class="toc-text">拉斯维加斯算法求解Hamilton回路问题（是否有Hamilton回路）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8B%89%E6%96%AF%E7%BB%B4%E5%8A%A0%E6%96%AF%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E5%AD%90%E9%9B%86%E5%92%8C%E9%97%AE%E9%A2%98%EF%BC%88%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%92%8C%E4%B8%BAt%E7%9A%84%E5%AD%90%E9%9B%86%EF%BC%89"><span class="toc-text">拉斯维加斯算法求解子集和问题（是否存在和为t的子集）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8B%89%E6%96%AF%E7%BB%B4%E5%8A%A0%E6%96%AF%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E5%9B%A2%E9%97%AE%E9%A2%98%EF%BC%88%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E9%A1%B6%E7%82%B9%E6%95%B0%E4%B8%8D%E5%B0%8F%E4%BA%8Ek%E7%9A%84%E5%9B%A2%EF%BC%89"><span class="toc-text">拉斯维加斯算法求解团问题（是否存在顶点数不小于k的团）</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: rgba(255,255,255,0.7)"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Alexie-Z-Yevich</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async src="/js/title.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>